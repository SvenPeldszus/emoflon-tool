
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.common.notify.NotificationChain;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EEnumLiteral;
import org.eclipse.emf.ecore.EGenericType;
import org.eclipse.emf.ecore.EModelElement;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EParameter;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.ETypeParameter;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.impl.ENotificationImpl;
import org.eclipse.emf.ecore.impl.EObjectImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.moflon.core.utilities.MoflonUtil;
import org.moflon.csp.codegenerator.MyBasicFormatRenderer;
import org.moflon.tgg.algorithm.delta.AttributeDelta;
import org.moflon.tgg.algorithm.delta.attribute.AttributConstraintContainer;
import org.moflon.tgg.algorithm.delta.attribute.AttributeConstraintCodeGenerator;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroupFile;

import MocaTree.MocaTreeFactory;
import MocaTree.Node;
import SDMLanguage.expressions.ComparingOperator;
import SDMLanguage.expressions.ComparisonExpression;
import SDMLanguage.expressions.Expression;
import SDMLanguage.expressions.LiteralExpression;
import SDMLanguage.patterns.AttributeAssignment;
import SDMLanguage.patterns.BindingOperator;
import SDMLanguage.patterns.Constraint;
import SDMLanguage.patterns.ObjectVariable;
import SDMLanguage.patterns.patternExpressions.AttributeValueExpression;
import SDMLanguage.sdmUtil.CompilerInjection;
import SDMLanguage.sdmUtil.CompilerInjectionEntry;
import SDMLanguage.sdmUtil.ImportInjectionEntry;
import SDMLanguage.sdmUtil.SdmUtilFactory;
import TGGLanguage.Domain;
import TGGLanguage.DomainType;
import TGGLanguage.TGGObjectVariable;
import TGGLanguage.TGGRule;
import TGGLanguage.algorithm.ApplicationTypes;
import TGGLanguage.compiler.CompilerPackage;
import TGGLanguage.compiler.TGGCompiler;
import TGGLanguage.compiler.compilerfacade.CompilerfacadePackage;
import TGGLanguage.compiler.compilerfacade.Helper;
import TGGLanguage.compiler.compilerfacade.InjectionHelper;
import TGGLanguage.csp.AttributeVariable;
import TGGLanguage.csp.CSP;
import TGGLanguage.csp.CspFactory;
import TGGLanguage.csp.Literal;
import TGGLanguage.csp.LocalVariable;
import TGGLanguage.csp.OperationalCSP;
import TGGLanguage.csp.TGGConstraint;
import TGGLanguage.csp.Variable;


partial class InjectionHelperImpl {

@members <--


	
	
	private void handleImports(final EClass ruleClass) {
		ImportInjectionEntry entryForNodeMapping = SdmUtilFactory.eINSTANCE
				.createImportInjectionEntry();
		entryForNodeMapping.setContent("TGGRuntime.TripleMatchNodeMapping");
		entryForNodeMapping.setEClass(ruleClass);
		this.getCompilerInjection().getImportInjectionEntries()
				.add(entryForNodeMapping);

		ImportInjectionEntry entryForOptional = SdmUtilFactory.eINSTANCE
				.createImportInjectionEntry();
		entryForOptional.setContent("java.util.Optional");
		entryForOptional.setEClass(ruleClass);
		this.getCompilerInjection().getImportInjectionEntries()
				.add(entryForOptional);
	}

	
	private OperationalCSP computeOCSP(TGGRule rule) {
		CSP csp = EcoreUtil.copy(rule.getCsp());
		OperationalCSP ocsp = CspFactory.eINSTANCE.createOperationalCSP();
		ocsp.getConstraints().addAll(csp.getConstraints());
		ocsp.getVariables().addAll(csp.getVariables());
		ocsp.getVariables().forEach(v -> {
			// Local variables are never bound
				if (!(v instanceof LocalVariable))
					v.setBound(true);
			});

		CSPSearchPlanAdapterImpl plan = new CSPSearchPlanAdapterImpl();
		plan.computeConstraintOrder(ocsp);
		
		return ocsp;
	}

	
-->

@model createInjectionForCheckAttributesMethod (String name, TGGRule rule, EClass ruleClass) <--

		
		handleImports(ruleClass);
		
		AttributeConstraintCodeGenerator codeGen = new AttributeConstraintCodeGenerator();
		
		OperationalCSP ocsp = computeOCSP(rule);
		codeGen.setTGGRule(rule);
		codeGen.setDirection(name);
		codeGen.setOCSP(ocsp);

		return codeGen.getInjection();
-->

@model createInjectionForCheckTypesMethod (TGGRule rule, EOperation eOperation, Helper compilerHelper, ApplicationTypes direction) <--

		boolean forward = direction.equals(ApplicationTypes.FORWARD);
		Domain sourceDomain = rule.getSource();
		Domain targetDomain = rule.getTarget();

		String injectionContent = "return "
				+ rule.getObjectVariable()
						.stream()
						.filter(ov -> {
							Domain domain = ((TGGObjectVariable) ov)
									.getDomain();
							boolean hasCorrectDomain = (forward && domain
									.equals(sourceDomain))
									|| (!forward && domain.equals(targetDomain));
							boolean isGreenInRule = ov.getBindingOperator()
									.equals(BindingOperator.CREATE);
							return hasCorrectDomain && isGreenInRule;
						}).map(compilerHelper::determineTypeCheckStatement)
						.reduce("true", (acc, str) -> acc + " && " + str) + ";";

		if (compilerInjection == null) {
			setCompilerInjection(SdmUtilFactory.eINSTANCE
					.createCompilerInjection());
		}

		CompilerInjectionEntry entry = SdmUtilFactory.eINSTANCE
				.createCompilerInjectionEntry();
		entry.setContent(injectionContent);
		entry.setEOperation(eOperation);

		getCompilerInjection().getCompilerInjectionEntries().add(entry);
-->

}