/*
 * generated by Xtext 2.10.0
 */
package org.moflon.gt.mosl.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.moflon.gt.mosl.moslgt.EClassDef
import org.moflon.codegen.eclipse.CodeGeneratorPlugin
import org.moflon.gt.mosl.moslgt.GraphTransformationFile
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EClass
import org.moflon.ide.mosl.core.scoping.ScopeProviderHelper
import org.moflon.gt.mosl.moslgt.MethodDec
import org.eclipse.emf.ecore.EClassifier
import org.moflon.ide.mosl.core.exceptions.CannotFindScopeException
import org.apache.log4j.Logger
import org.moflon.gt.mosl.moslgt.PatternStatement
import org.moflon.gt.mosl.moslgt.LinkVariablePattern
import org.moflon.gt.mosl.moslgt.MethodParameter
import org.moflon.gt.mosl.moslgt.CalledPatternParameter
import org.eclipse.xtext.scoping.IScope
import java.util.Stack
import org.moflon.gt.mosl.moslgt.Statement
import org.moflon.gt.mosl.moslgt.NextStatement
import java.util.ArrayList
import SDMLanguage.patterns.ObjectVariable
import org.moflon.gt.mosl.moslgt.ConditionStatement
import org.moflon.gt.mosl.moslgt.LoopStatement
import org.moflon.gt.mosl.moslgt.ConditionContainingStatement
import org.moflon.gt.mosl.moslgt.ObjectVariablePattern
import org.moflon.gt.mosl.moslgt.ObjectVariableStatement

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MOSLGTScopeProvider extends AbstractMOSLGTScopeProvider {
	private ScopeProviderHelper<EPackage> helper = new ScopeProviderHelper();
	private Logger log = Logger.getLogger(MOSLGTScopeProvider.getClass());
	
	override getScope(EObject context, EReference reference) {
	try{
		if(searchForEClass(context,reference)){
			return getScopeByType(context, EClass)
		}
		else if(searchForEClassifier(context,reference)){
			return getScopeByType(context, EClassifier)
		}
		else if(searchForCalledPatternParameter(context, reference))
			return getScopeForCalledParameter(CalledPatternParameter.cast(context))
//		else if(searchForPattern(context, reference))
//			return getScopeByType(context, PatternDef)
		else if(searchForEReferences(context, reference)){
			return getScopeByType(context, EReference)
		}
	}catch (CannotFindScopeException e){
		log.debug("Cannot find Scope",e)
	}
		super.getScope(context, reference);
	}
	
	def boolean searchForCalledPatternParameter(EObject context, EReference reference) {
		return context instanceof CalledPatternParameter;
	}
	
	def boolean searchForEReferences(EObject context, EReference reference) {
		return context instanceof LinkVariablePattern && reference.name.equals("type")
	}
	
	def boolean searchForPattern(EObject context, EReference reference) {
		return context instanceof PatternStatement
	}
	
	def IScope getScopeForCalledParameter(CalledPatternParameter cpp){
		var method = MethodDec.cast(cpp.eContainer)
		var candidates = getAllDefinitions(method)
		
		null 
		
	}
	
	def getAllDefinitions(MethodDec method){
		var stack = new Stack<Statement>()
		var candidates = new ArrayList<ObjectVariable>
		stack.push(method.startStatement)
		while(!stack.isEmpty){
			var statement = stack.pop
			if(statement instanceof NextStatement){
				stack.push(statement.next)
				if(statement instanceof ConditionStatement){
					stack.push(statement.elseStartStatement)
					stack.push(statement.thenStartStatement)
				}
				else if(statement instanceof LoopStatement){
					stack.push(statement.loopStartStatement)	
				}
				else if(statement instanceof PatternStatement){
					
				}				
			}				 
				
						
		}
		candidates
	}
	
	def getScopeByType(EObject context, Class<? extends EObject> type)throws CannotFindScopeException{
		val set = helper.resourceSet
		CodeGeneratorPlugin.createPluginToResourceMapping(set);		
		var gtf = getGraphTransformationFile(context)
		var uris = gtf.imports.map[importValue | URI.createURI(importValue.name)];
		return helper.createScope(uris, EPackage, type);		 
	}
	
	def GraphTransformationFile getGraphTransformationFile(EObject context){
		if(context === null)
			return null
		else if(context instanceof GraphTransformationFile)
			return context
		else
			return getGraphTransformationFile(context.eContainer)
	}
	
	def boolean searchForEClass(EObject context, EReference reference){
		return context instanceof EClassDef 
	}
	
	def boolean searchForEClassifier(EObject context, EReference reference){
		return context instanceof MethodDec || context instanceof ObjectVariablePattern || context instanceof ObjectVariableStatement 
		|| (context instanceof MethodParameter && reference.name.equals("type"))
	}
	
}
