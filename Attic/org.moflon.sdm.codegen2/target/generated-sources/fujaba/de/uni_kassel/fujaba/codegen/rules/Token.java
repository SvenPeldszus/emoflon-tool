/*
 * generated by Fujaba - CodeGen2
 */
package de.uni_kassel.fujaba.codegen.rules;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.NoSuchElementException;

import de.uni_kassel.features.ReferenceHandler; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.features.annotation.util.Property; // requires Fujaba5/libs/features.jar in classpath
import de.upb.tools.fca.FEmptyListIterator;
import de.upb.tools.fca.FLinkedList; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDM; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDMException;


public abstract class Token extends Object
{


   /**
    * <pre>
    *           0..1     children     0..n
    * Token ------------------------- Token
    *           parent               children
    * </pre>
    */
   public static final String PROPERTY_CHILDREN = "children";

   @Property( name = PROPERTY_CHILDREN, partner = Token.PROPERTY_PARENT, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.COMPOSITION)
   private FLinkedList<Token> children;

   @Property( name = PROPERTY_CHILDREN )
   public List<? extends Token> getChildren()
   {
      return ((this.children == null)
              ? Collections.EMPTY_LIST
              : Collections.unmodifiableList(this.children));
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean addToChildren (Token value)
   {
      boolean changed = false;

      if (value != null && !this.hasInChildren (value))
      {
         if (this.children == null)
         {
            this.children = new FLinkedList<Token> ();

         }
      
         changed = this.children.add (value);
         if (changed)
         {
            value.setParent (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public Token withChildren (Token value)
   {
      addToChildren (value);
      return this;
   }

   public Token withoutChildren (Token value)
   {
      removeFromChildren (value);
      return this;
   }


   public boolean removeFromChildren (Token value)
   {
      boolean changed = false;

      if ((this.children != null) && (value != null))
      {
      
         changed = this.children.remove (value);
         if (changed)
         {
            value.setParent (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public void removeAllFromChildren (){
   
      Token tmpValue;
      Iterator<? extends Token> iter = this.iteratorOfChildren ();
      while (iter.hasNext ())
      {
         tmpValue = (Token) iter.next ();
         this.removeFromChildren (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean hasInChildren (Token value)
   {
      return ((this.children != null) &&
              (value != null) &&
              this.children.contains (value));
   }

   @Property( name = PROPERTY_CHILDREN )
   public ListIterator<? extends Token> iteratorOfChildren ()
   {
      return ((this.children == null)
              ? FEmptyListIterator.<Token>get ()
              : this.children.listIterator());
   }

   @Property( name = PROPERTY_CHILDREN )
   public int sizeOfChildren ()
   {
      return ((this.children == null)
              ? 0
              : this.children.size ());
   }
   @Property( name = PROPERTY_CHILDREN )
   public Token getFirstOfChildren ()
   {
      if (children == null)
      {
         return null;
      }
      else
      {
         if (children.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (Token) children.getFirst ();
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public Token getLastOfChildren ()
   {
      if (children == null)
      {
         return null;
      }
      else
      {
         if (children.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (Token) children.getLast ();
      }
   }
   @Property( name = PROPERTY_CHILDREN )
   public Token getFromChildren ( int index )
   {
      if (index >= 0 && index < sizeOfChildren ())
      {
         return (Token) this.children.get (index);
      }
      else
      {
         throw new IllegalArgumentException ("getChildrenAt(" + index + ")" );
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public int indexOfChildren ( Token value )
   {
      return ((this.children == null)
              ? -1
              : this.children.indexOf (value));
   }

   @Property( name = PROPERTY_CHILDREN )
   public int indexOfChildren ( Token value, int index )
   {
      return ((this.children == null)
   	       ? -1
   	       : this.children.indexOf (value, index));
   }

   @Property( name = PROPERTY_CHILDREN )
   public int lastIndexOfChildren ( Token value )
   {
      return ((this.children == null)
               ? -1
               : this.children.lastIndexOf (value));
   }

   @Property( name = PROPERTY_CHILDREN )
   public int lastIndexOfChildren ( Token value, int index )
   {
      return ((this.children == null)
               ? -1
               : this.children.lastIndexOf (value, index));
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean isBeforeOfChildren ( Token leftObject, Token rightObject)
   {
      if (children == null)
      {
         return false;
      }
      else
      {
         return children.isBefore (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean isAfterOfChildren ( Token leftObject, Token rightObject)
   {
      if (children == null)
      {
         return false;
      }
      else
      {
         return children.isAfter (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public Token getNextOfChildren ( Token object )
   {
      if (children == null)
      {
         return null;
      }
      else
      {
         return (Token) children.getNextOf (object);
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public Token getNextOfChildren ( Token object, int index)
   {
      if (children == null)
      {
         return null;
      }
      else
      {
         return (Token) children.getNextOf (object, index);
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public Token getPreviousOfChildren ( Token object)
   {
      if (children == null)
      {
         return null;
      }
      else
      {
         return (Token) children.getPreviousOf (object);
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public Token getPreviousOfChildren ( Token object, int index )
   {
      if (children == null)
      {
         return null;
      }
      else
      {
         return (Token) children.getPreviousOf (object, index);
      }
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean addAfterOfChildren ( Token refObject, Token value)
   {
      boolean changed = false;
      if (children != null)
      {
         int index = children.indexOf (refObject);
         changed = addToChildren (index+1, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean addBeforeOfChildren ( Token refObject, Token value)
   {
      boolean changed = false;
      if (children != null)
      {
         int index = children.indexOf (refObject);
         changed = addToChildren (index, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean addToChildren (int index, Token value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.children == null)
         {
            this.children = new FLinkedList<Token> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfChildren (value);
         if (oldIndex != index)
         {
            try
            {
            
               if (oldIndex > -1)
               {
                  children.remove (oldIndex);
               }
               children.add (index, value);
               if (oldIndex < 0)
               {
                  value.setParent (this);
               }
               changed = true;
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean setInChildren (int index, Token value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.children == null)
         {
            this.children = new FLinkedList<Token> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfChildren (value);
         if (oldIndex != index)
         {
            try
            {
            
               Token oldValue = (Token)this.children.set (index, value);
               if (oldIndex > -1)
               {
                  this.children.remove (oldIndex);
               }
               if (oldValue != value)
               {
                  if (oldValue != null)
                  {
                     oldValue.setParent (null);
                  }
                  if (oldIndex < 0)
                  {
                     value.setParent (this);
                  }
                  changed = true;
               }
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean removeFromChildren (int index)
   {
      boolean changed = false;

      if (this.children != null && (index >= 0 && index < this.children.size ()))
      {
      
         Token tmpValue = (Token) this.children.remove (index);
         if (tmpValue != null)
         {
            tmpValue.setParent (null);
            changed = true;
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public boolean removeFromChildren (int index, Token value)
   {
      boolean changed = false;

      if ((this.children != null) && (value != null) && 
          (index >= 0 && index < this.children.size ()))
      {
         Token oldValue = (Token) this.children.get (index);
         if (oldValue == value)
         {
         
            changed = this.removeFromChildren (index);
         
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_CHILDREN )
   public ListIterator<? extends Token> iteratorOfChildren ( Token  lowerBound )
   {
      ListIterator<Token> result = FEmptyListIterator.<Token>get ();

      if (children != null && lowerBound != null)
      {
         int index = children.indexOf (lowerBound) + 1;
         result = children.listIterator (index);
      }
      else if (children != null && lowerBound == null)
      {
         result = children.listIterator (0);
      }

      return result;
   }

   @Property( name = PROPERTY_CHILDREN )
   public ListIterator<? extends Token> iteratorOfChildren (int index)
   {
      return ((this.children == null)
              ? FEmptyListIterator.<Token>get ()
              : this.children.listIterator (Math.max(0,Math.min(index,this.children.size ()))));
   }

   public Token getChildOfLeastCommonAncestor (Token op )
   {
      boolean fujaba__Success = false;
      Token tmpOp = null;
      LinkedList thisAncestors = null;
      LinkedList opAncestors = null;
      Object _TmpObject = null;

      if ( op == null )
      {
         return null;

      }
      if ( this == op )
      {
         return null;

      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object op is really bound
         JavaSDM.ensure ( op != null );
         // check isomorphic binding between objects this and op
         JavaSDM.ensure ( !this.equals (op) );

         // check link children from op to this
         JavaSDM.ensure (this.equals (op.getParent ()));

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return null;

      }
      // story pattern Successor of storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object op is really bound
         JavaSDM.ensure ( op != null );
         // check isomorphic binding between objects this and op
         JavaSDM.ensure ( !this.equals (op) );

         // check link children from this to op
         JavaSDM.ensure (op.equals (this.getParent ()));

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return this;

      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         tmpOp = this;

         // check object tmpOp is really bound
         JavaSDM.ensure ( tmpOp != null );
         // create object thisAncestors
         thisAncestors = new LinkedList ( );

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      do
      {
         // story pattern Successor of storypatternwiththis
         try 
         {
            fujaba__Success = false; 

            // check object thisAncestors is really bound
            JavaSDM.ensure ( thisAncestors != null );
            // check object tmpOp is really bound
            JavaSDM.ensure ( tmpOp != null );
            // create link contains from thisAncestors to tmpOp
            thisAncestors.add (tmpOp);

            // collabStat call
            tmpOp = tmpOp.getParent();
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      while ( fujaba__Success );// story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         tmpOp = op;

         // check object tmpOp is really bound
         JavaSDM.ensure ( tmpOp != null );
         // create object opAncestors
         opAncestors = new LinkedList ( );

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      do
      {
         // story pattern Successor of storypatternwiththis
         try 
         {
            fujaba__Success = false; 

            // check object opAncestors is really bound
            JavaSDM.ensure ( opAncestors != null );
            // check object tmpOp is really bound
            JavaSDM.ensure ( tmpOp != null );
            // create link contains from opAncestors to tmpOp
            opAncestors.add (tmpOp);

            // collabStat call
            tmpOp = tmpOp.getParent();
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      while ( fujaba__Success );try {
      do
      {
         // story pattern Successor of Successor of storypatternwiththis
         try 
         {
            fujaba__Success = false; 

            // check object opAncestors is really bound
            JavaSDM.ensure ( opAncestors != null );
            // check object thisAncestors is really bound
            JavaSDM.ensure ( thisAncestors != null );
            // check isomorphic binding between objects thisAncestors and opAncestors
            JavaSDM.ensure ( !thisAncestors.equals (opAncestors) );

            // search to-one link contains from thisAncestors to tmpOp
            _TmpObject = thisAncestors.getLast ();

            // ensure correct type and really bound of object tmpOp
            JavaSDM.ensure ( _TmpObject instanceof Token );
            tmpOp = (Token) _TmpObject;


            // check link contains from opAncestors to tmpOp
            JavaSDM.ensure (tmpOp.equals (opAncestors.getLast ()));


            // destroy link contains from thisAncestors to tmpOp
            thisAncestors.remove (tmpOp);
            // destroy link contains from opAncestors to tmpOp
            opAncestors.remove (tmpOp);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      while ( fujaba__Success );}catch (NoSuchElementException e) {}
      try
      {
      // story pattern Successor of Successor of Successor of storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object thisAncestors is really bound
         JavaSDM.ensure ( thisAncestors != null );
         // search to-one link contains from thisAncestors to tmpOp
         _TmpObject = thisAncestors.getLast ();

         // ensure correct type and really bound of object tmpOp
         JavaSDM.ensure ( _TmpObject instanceof Token );
         tmpOp = (Token) _TmpObject;



         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      }catch (NoSuchElementException e) {}
      if ( !( fujaba__Success ) )
      {
         return this;

      }
      return tmpOp;
   }

   public List getChildrenList ()
   {

      return children;
   }

   public String getContext ()
   {

      return "children";
   }

   public Token getLeastCommonAncestor (Token op )
   {
      boolean fujaba__Success = false;
      Token ancestor = null;
      Token parent = null;

      if ( op == null )
      {
         return null;

      }
      if ( this == op )
      {
         return this;

      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object op is really bound
         JavaSDM.ensure ( op != null );
         // check isomorphic binding between objects this and op
         JavaSDM.ensure ( !this.equals (op) );

         // check link children from op to this
         JavaSDM.ensure (this.equals (op.getParent ()));

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return this;

      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         ancestor = getChildOfLeastCommonAncestor (op);

         // check object ancestor is really bound
         JavaSDM.ensure ( ancestor != null );
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         return null;

      }
      // story pattern Successor of storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object ancestor is really bound
         JavaSDM.ensure ( ancestor != null );
         // search to-one link children from ancestor to parent
         parent = ancestor.getParent ();

         // check object parent is really bound
         JavaSDM.ensure ( parent != null );

         // check isomorphic binding between objects parent and ancestor
         JavaSDM.ensure ( !parent.equals (ancestor) );


         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return parent;
   }

   public boolean isAncestorOf (Token op )
   {
      boolean fujaba__Success = false;
      Token ancestor = null;

      // story pattern 
      try 
      {
         fujaba__Success = false; 

         ancestor = getLeastCommonAncestor (op);

         // check object ancestor is really bound
         JavaSDM.ensure ( ancestor != null );
         // constraint ancestor == this
         JavaSDM.ensure ( ancestor == this );
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return true;

      }
      return false;
   }

   public boolean isSuccessorOf (Token op )
   {
      boolean fujaba__Success = false;
      Token parent = null;
      Iterator fujaba__IterParentToOtherOp = null;
      Token otherOp = null;
      Iterator fujaba__IterParentToTmpOp = null;
      Token tmpOp = null;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // constraint this.isAncestorOf (op)
         JavaSDM.ensure ( this.isAncestorOf (op) );
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return false;

      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         parent = getLeastCommonAncestor (op);

         // check object parent is really bound
         JavaSDM.ensure ( parent != null );
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         return false;

      }
      // story pattern Successor of storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object op is really bound
         JavaSDM.ensure ( op != null );
         // check object parent is really bound
         JavaSDM.ensure ( parent != null );
         // check isomorphic binding between objects parent and op
         JavaSDM.ensure ( !parent.equals (op) );

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         return true;

      }
      // story pattern Successor of Successor of storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object parent is really bound
         JavaSDM.ensure ( parent != null );
         // iterate to-many link children from parent to tmpOp
         fujaba__Success = false;
         fujaba__IterParentToTmpOp = parent.iteratorOfChildren ();

         while ( !(fujaba__Success) && fujaba__IterParentToTmpOp.hasNext () )
         {
            try
            {
               tmpOp = (Token) fujaba__IterParentToTmpOp.next ();

               // check object tmpOp is really bound
               JavaSDM.ensure ( tmpOp != null );
               // check isomorphic binding between objects tmpOp and parent
               JavaSDM.ensure ( !tmpOp.equals (parent) );

               // search multilink UMLMultiLink[{...}]
               // iterate to-many link children from parent to otherOp
               fujaba__Success = false;
               fujaba__IterParentToOtherOp = parent.iteratorOfChildren (tmpOp);

               while ( !(fujaba__Success) && fujaba__IterParentToOtherOp.hasNext () )
               {
                  try
                  {
                     otherOp = (Token) fujaba__IterParentToOtherOp.next ();

                     // check object otherOp is really bound
                     JavaSDM.ensure ( otherOp != null );
                     // check isomorphic binding between objects parent and otherOp
                     JavaSDM.ensure ( !parent.equals (otherOp) );

                     // check isomorphic binding between objects tmpOp and otherOp
                     JavaSDM.ensure ( !tmpOp.equals (otherOp) );

                     // constraint otherOp == this || otherOp.isAncestorOf(this)
                     JavaSDM.ensure ( otherOp == this || otherOp.isAncestorOf(this) );
                     // constraint tmpOp == op || tmpOp.isAncestorOf(op)
                     JavaSDM.ensure ( tmpOp == op || tmpOp.isAncestorOf(op) );

                     fujaba__Success = true;
                  }
                  catch ( JavaSDMException fujaba__InternalException )
                  {
                     fujaba__Success = false;
                  }
               }
               JavaSDM.ensure (fujaba__Success);

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return true;

      }
      return false;
   }

   /**
    * <pre>
    *           0..n     children     0..1
    * Token ------------------------- Token
    *           children               parent
    * </pre>
    */
   public static final String PROPERTY_PARENT = "parent";

   @Property( name = PROPERTY_PARENT, partner = Token.PROPERTY_CHILDREN, kind = ReferenceHandler.ReferenceKind.TO_ONE,
         adornment = ReferenceHandler.Adornment.PARENT)
   private Token parent;

   @Property( name = PROPERTY_PARENT )
   public boolean setParent (Token value)
   {
      boolean changed = false;

      if (this.parent != value)
      {
      
         Token oldValue = this.parent;
         Token source = this;
         if (this.parent != null)
         {
            this.parent = null;
            oldValue.removeFromChildren (this);
         }
         this.parent = value;

         if (value != null)
         {
            value.addToChildren (this);
         }
         changed = true;
      
      }
      return changed;
   }

   @Property( name = PROPERTY_PARENT )
   public Token withParent (Token value)
   {
      setParent (value);
      return this;
   }

   public Token getParent ()
   {
      return this.parent;
   }

   public void removeYou()
   {
      for (Iterator iterChildren = this.iteratorOfChildren (); iterChildren.hasNext ();)
      {
         ((Token)iterChildren.next ()).removeYou ();
      }
      this.setParent (null);
   }
}


