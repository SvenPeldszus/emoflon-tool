/*
 * generated by Fujaba - CodeGen2
 */
package de.uni_kassel.fujaba.codegen.rules.engine;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import de.uni_kassel.fujaba.codegen.rules.ExecuteStoryPatternOperation;
import de.uni_kassel.fujaba.codegen.rules.ObjectSet;
import de.uni_kassel.fujaba.codegen.rules.SearchOperation;
import de.uni_kassel.fujaba.codegen.rules.Token;
import de.uni_kassel.fujaba.codegen.rules.UMLObjectRef;
import de.uni_paderborn.fujaba.uml.behavior.UMLObject;
import de.upb.tools.sdm.JavaSDM; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDMException;


public class SearchTreeMutator extends PlanMutator
{


   private void createSpanningTreeNode (UMLObjectRef source , ObjectSet objects , Set searches , SortedSet minQueue )
   {
      boolean fujaba__Success = false;
      Token parent = null;
      UMLObjectRef unboundRef = null;
      Iterator fujaba__IterSourceToSearch = null;
      Object _TmpObject = null;
      SearchOperation search = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         parent = findParentOp (source, searches);

         // check object parent is really bound
         JavaSDM.ensure ( parent != null );
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         // story pattern successor
         try 
         {
            fujaba__Success = false; 

            // check object objects is really bound
            JavaSDM.ensure ( objects != null );
            // check object source is really bound
            JavaSDM.ensure ( source != null );
            // iterate to-many link needs from source to search
            fujaba__Success = false;
            fujaba__IterSourceToSearch = source.iteratorOfDependentOperations ();

            while ( fujaba__IterSourceToSearch.hasNext () )
            {
               try
               {
                  _TmpObject =  fujaba__IterSourceToSearch.next ();

                  // ensure correct type and really bound of object search
                  JavaSDM.ensure ( _TmpObject instanceof SearchOperation );
                  search = (SearchOperation) _TmpObject;

                  // search to-one link subject from search to unboundRef
                  unboundRef = search.getSubject ();

                  // check object unboundRef is really bound
                  JavaSDM.ensure ( unboundRef != null );

                  // check isomorphic binding between objects unboundRef and source
                  JavaSDM.ensure ( !unboundRef.equals (source) );

                  // check link items from unboundRef to objects
                  JavaSDM.ensure (unboundRef.hasInList (objects));

                  // constraint processSearch(source, objects, searches, minQueue, search, unboundRef)
                  JavaSDM.ensure ( processSearch(source, objects, searches, minQueue, search, unboundRef) );
                  // story pattern successor
                  try 
                  {
                     fujaba__Success = false; 

                     // check object parent is really bound
                     JavaSDM.ensure ( parent != null );
                     // check object search is really bound
                     JavaSDM.ensure ( search != null );
                     // check object searches is really bound
                     JavaSDM.ensure ( searches != null );
                     // check isomorphic binding between objects search and parent
                     JavaSDM.ensure ( !search.equals (parent) );

                     // create link children from search to parent
                     search.setParent (parent);

                     // create link contains from searches to search
                     searches.add (search);

                     fujaba__Success = true;
                  }
                  catch ( JavaSDMException fujaba__InternalException )
                  {
                     fujaba__Success = false;
                  }



                  fujaba__Success = true;
               }
               catch ( JavaSDMException fujaba__InternalException )
               {
                  fujaba__Success = false;
               }
            }
            JavaSDM.ensure (fujaba__Success);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }

         return ;

      }
      // story pattern 
      try 
      {
         fujaba__Success = false; 

         // collabStat call
         getEngine ().internalError ("Cannot determine search operation through which object was discovered", null);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   protected void createSpanningTree (ExecuteStoryPatternOperation plan , ObjectSet objects )
   {
      boolean fujaba__Success = false;
      TreeSet minQueue = null;
      Object _TmpObject = null;
      ObjectSet tmpObjects = null;
      HashSet searches = null;
      ObjectSet negObjects = null;
      UMLObject obj = null;
      Iterator fujaba__IterTmpObjectsToObjRef = null;
      UMLObjectRef objRef = null;
      Iterator fujaba__IterTmpObjectsToMin = null;
      UMLObjectRef min = null;
      Iterator fujaba__IterSearchToBoundRef = null;
      UMLObjectRef boundRef = null;
      Iterator fujaba__IterObjRefToSearch = null;
      SearchOperation search = null;
      Iterator fujaba__IterNegObjectsToObjRef = null;
      Iterator fujaba__IterNegObjectsToMin = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         minQueue = new TreeSet ( new UMLObjectRefComparator() );

         // check object minQueue is really bound
         JavaSDM.ensure ( minQueue != null );
         _TmpObject = objects.clone ();

         // ensure correct type and really bound of object tmpObjects
         JavaSDM.ensure ( _TmpObject instanceof ObjectSet );
         tmpObjects = (ObjectSet) _TmpObject;

         // check object plan is really bound
         JavaSDM.ensure ( plan != null );
         // create object searches
         searches = new HashSet ( );

         // create object negObjects
         negObjects = new ObjectSet ( );

         // create link contains from searches to plan
         searches.add (plan);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object negObjects is really bound
         JavaSDM.ensure ( negObjects != null );
         // check object tmpObjects is really bound
         JavaSDM.ensure ( tmpObjects != null );
         // check isomorphic binding between objects tmpObjects and negObjects
         JavaSDM.ensure ( !tmpObjects.equals (negObjects) );

         // iterate to-many link items from tmpObjects to objRef
         fujaba__Success = false;
         fujaba__IterTmpObjectsToObjRef = tmpObjects.iteratorOfItems ();

         while ( fujaba__IterTmpObjectsToObjRef.hasNext () )
         {
            try
            {
               objRef = (UMLObjectRef) fujaba__IterTmpObjectsToObjRef.next ();

               // check object objRef is really bound
               JavaSDM.ensure ( objRef != null );
               // search to-one link ref from objRef to obj
               obj = objRef.getRef ();

               // check object obj is really bound
               JavaSDM.ensure ( obj != null );

               // attribute condition bound == false
               JavaSDM.ensure ( obj.isBound () == false );

               // constraint obj.isOptional()||obj.getType()==UMLObject.NEGATIVE
               JavaSDM.ensure ( obj.isOptional()||obj.getType()==UMLObject.NEGATIVE );
               // destroy link items from objRef to tmpObjects
               objRef.removeFromList (tmpObjects);
               // create link items from negObjects to objRef
               negObjects.addToItems (objRef);



               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // Initialize Prim's algorithm
      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object tmpObjects is really bound
         JavaSDM.ensure ( tmpObjects != null );
         // iterate to-many link items from tmpObjects to objRef
         fujaba__Success = false;
         fujaba__IterTmpObjectsToObjRef = tmpObjects.iteratorOfItems ();

         while ( fujaba__IterTmpObjectsToObjRef.hasNext () )
         {
            try
            {
               objRef = (UMLObjectRef) fujaba__IterTmpObjectsToObjRef.next ();

               // check object objRef is really bound
               JavaSDM.ensure ( objRef != null );
               // search to-one link ref from objRef to obj
               obj = objRef.getRef ();

               // check object obj is really bound
               JavaSDM.ensure ( obj != null );

               // attribute condition bound == true
               JavaSDM.ensure ( obj.isBound () == true );

               // destroy link items from objRef to tmpObjects
               objRef.removeFromList (tmpObjects);
               // collabStat call
               this.createSpanningTreeNode (objRef, tmpObjects, searches, minQueue);


               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      do
      {
         // Incrementally build Spanning Tree
         // story pattern successor
         try 
         {
            fujaba__Success = false; 

            // check object minQueue is really bound
            JavaSDM.ensure ( minQueue != null );
            // check object tmpObjects is really bound
            JavaSDM.ensure ( tmpObjects != null );
            // iterate to-many link items from tmpObjects to min
            fujaba__Success = false;
            fujaba__IterTmpObjectsToMin = tmpObjects.iteratorOfItems ();

            while ( !(fujaba__Success) && fujaba__IterTmpObjectsToMin.hasNext () )
            {
               try
               {
                  min = (UMLObjectRef) fujaba__IterTmpObjectsToMin.next ();

                  // check object min is really bound
                  JavaSDM.ensure ( min != null );
                  // check link contains from minQueue to min
                  JavaSDM.ensure (minQueue.contains (min));


                  fujaba__Success = true;
               }
               catch ( JavaSDMException fujaba__InternalException )
               {
                  fujaba__Success = false;
               }
            }
            JavaSDM.ensure (fujaba__Success);
            // destroy link items from tmpObjects to min
            tmpObjects.removeFromItems (min);
            // destroy link contains from minQueue to min
            minQueue.remove (min);
            // collabStat call
            this.createSpanningTreeNode (min, tmpObjects, searches, minQueue);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      while ( fujaba__Success );// story pattern Successor of successor
      try 
      {
         fujaba__Success = false; 

         // check object negObjects is really bound
         JavaSDM.ensure ( negObjects != null );
         // check object tmpObjects is really bound
         JavaSDM.ensure ( tmpObjects != null );
         // check isomorphic binding between objects tmpObjects and negObjects
         JavaSDM.ensure ( !tmpObjects.equals (negObjects) );

         // iterate to-many link items from negObjects to objRef
         fujaba__Success = false;
         fujaba__IterNegObjectsToObjRef = negObjects.iteratorOfItems ();

         while ( fujaba__IterNegObjectsToObjRef.hasNext () )
         {
            try
            {
               objRef = (UMLObjectRef) fujaba__IterNegObjectsToObjRef.next ();

               // check object objRef is really bound
               JavaSDM.ensure ( objRef != null );
               // iterate to-many link subject from objRef to search
               fujaba__Success = false;
               fujaba__IterObjRefToSearch = objRef.iteratorOfSubjectOf ();

               while ( fujaba__IterObjRefToSearch.hasNext () )
               {
                  try
                  {
                     _TmpObject =  fujaba__IterObjRefToSearch.next ();

                     // ensure correct type and really bound of object search
                     JavaSDM.ensure ( _TmpObject instanceof SearchOperation );
                     search = (SearchOperation) _TmpObject;

                     // iterate to-many link needs from search to boundRef
                     fujaba__Success = false;
                     fujaba__IterSearchToBoundRef = search.iteratorOfNeeds ();

                     while ( fujaba__IterSearchToBoundRef.hasNext () )
                     {
                        try
                        {
                           boundRef = (UMLObjectRef) fujaba__IterSearchToBoundRef.next ();

                           // check object boundRef is really bound
                           JavaSDM.ensure ( boundRef != null );
                           // check isomorphic binding between objects objRef and boundRef
                           JavaSDM.ensure ( !objRef.equals (boundRef) );

                           // check link items from boundRef to negObjects
                           JavaSDM.ensure (!(boundRef.hasInList (negObjects)));

                           // check link items from tmpObjects to boundRef
                           JavaSDM.ensure (!(tmpObjects.hasInItems (boundRef)));

                           // collabStat call
                           this.createSpanningTreeNode (boundRef, negObjects, searches, minQueue);

                           fujaba__Success = true;
                        }
                        catch ( JavaSDMException fujaba__InternalException )
                        {
                           fujaba__Success = false;
                        }
                     }
                     JavaSDM.ensure (fujaba__Success);

                     fujaba__Success = true;
                  }
                  catch ( JavaSDMException fujaba__InternalException )
                  {
                     fujaba__Success = false;
                  }
               }
               JavaSDM.ensure (fujaba__Success);

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      do
      {
         // story pattern Successor of successor
         try 
         {
            fujaba__Success = false; 

            // check object minQueue is really bound
            JavaSDM.ensure ( minQueue != null );
            // check object negObjects is really bound
            JavaSDM.ensure ( negObjects != null );
            // iterate to-many link items from negObjects to min
            fujaba__Success = false;
            fujaba__IterNegObjectsToMin = negObjects.iteratorOfItems ();

            while ( !(fujaba__Success) && fujaba__IterNegObjectsToMin.hasNext () )
            {
               try
               {
                  min = (UMLObjectRef) fujaba__IterNegObjectsToMin.next ();

                  // check object min is really bound
                  JavaSDM.ensure ( min != null );
                  // check link contains from minQueue to min
                  JavaSDM.ensure (minQueue.contains (min));


                  fujaba__Success = true;
               }
               catch ( JavaSDMException fujaba__InternalException )
               {
                  fujaba__Success = false;
               }
            }
            JavaSDM.ensure (fujaba__Success);
            // destroy link items from negObjects to min
            negObjects.removeFromItems (min);
            // destroy link contains from minQueue to min
            minQueue.remove (min);
            // collabStat call
            this.createSpanningTreeNode (min, negObjects, searches, minQueue);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      while ( fujaba__Success );// reachability check: objects should be empty now.
      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object tmpObjects is really bound
         JavaSDM.ensure ( tmpObjects != null );
         // iterate to-many link items from tmpObjects to objRef
         fujaba__Success = false;
         fujaba__IterTmpObjectsToObjRef = tmpObjects.iteratorOfItems ();

         while ( !(fujaba__Success) && fujaba__IterTmpObjectsToObjRef.hasNext () )
         {
            try
            {
               objRef = (UMLObjectRef) fujaba__IterTmpObjectsToObjRef.next ();

               // check object objRef is really bound
               JavaSDM.ensure ( objRef != null );
               // search to-one link ref from objRef to obj
               obj = objRef.getRef ();

               // check object obj is really bound
               JavaSDM.ensure ( obj != null );

               // attribute condition modifier != UMLObject.CREATE
               JavaSDM.ensure ( obj.getModifier () != UMLObject.CREATE );



               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         // story pattern 
         try 
         {
            fujaba__Success = false; 

            // check object negObjects is really bound
            JavaSDM.ensure ( negObjects != null );
            // iterate to-many link items from negObjects to objRef
            fujaba__Success = false;
            fujaba__IterNegObjectsToObjRef = negObjects.iteratorOfItems ();

            while ( !(fujaba__Success) && fujaba__IterNegObjectsToObjRef.hasNext () )
            {
               try
               {
                  objRef = (UMLObjectRef) fujaba__IterNegObjectsToObjRef.next ();

                  // check object objRef is really bound
                  JavaSDM.ensure ( objRef != null );
                  // search to-one link ref from objRef to obj
                  obj = objRef.getRef ();

                  // check object obj is really bound
                  JavaSDM.ensure ( obj != null );

                  // attribute condition modifier != UMLObject.CREATE
                  JavaSDM.ensure ( obj.getModifier () != UMLObject.CREATE );



                  fujaba__Success = true;
               }
               catch ( JavaSDMException fujaba__InternalException )
               {
                  fujaba__Success = false;
               }
            }
            JavaSDM.ensure (fujaba__Success);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }

         if ( !( fujaba__Success ) )
         {
            return ;

         }

      }
      // story pattern Successor of successor
      try 
      {
         fujaba__Success = false; 

         // collabStat call
         getEngine().warning ("Object is not bound and cannot be reached from a bound object", obj);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   private Token findParentOp (UMLObjectRef obj , Set searches )
   {
      boolean fujaba__Success = false;
      Iterator fujaba__IterObjToSearchOp = null;
      Object _TmpObject = null;
      SearchOperation searchOp = null;
      UMLObject realObj = null;
      Iterator fujaba__IterSearchesToPlan = null;
      ExecuteStoryPatternOperation plan = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object obj is really bound
         JavaSDM.ensure ( obj != null );
         // check object searches is really bound
         JavaSDM.ensure ( searches != null );
         // iterate to-many link subject from obj to searchOp
         fujaba__Success = false;
         fujaba__IterObjToSearchOp = obj.iteratorOfSubjectOf ();

         while ( !(fujaba__Success) && fujaba__IterObjToSearchOp.hasNext () )
         {
            try
            {
               _TmpObject =  fujaba__IterObjToSearchOp.next ();

               // ensure correct type and really bound of object searchOp
               JavaSDM.ensure ( _TmpObject instanceof SearchOperation );
               searchOp = (SearchOperation) _TmpObject;

               // check link contains from searches to searchOp
               JavaSDM.ensure (searches.contains (searchOp));


               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return searchOp;

      }
      // story pattern Successor of successor
      try 
      {
         fujaba__Success = false; 

         // check object obj is really bound
         JavaSDM.ensure ( obj != null );
         // check object searches is really bound
         JavaSDM.ensure ( searches != null );
         // search to-one link ref from obj to realObj
         realObj = obj.getRef ();

         // check object realObj is really bound
         JavaSDM.ensure ( realObj != null );


         // iterate to-many link contains from searches to plan
         fujaba__Success = false;
         fujaba__IterSearchesToPlan = searches.iterator ();

         while ( !(fujaba__Success) && fujaba__IterSearchesToPlan.hasNext () )
         {
            try
            {
               _TmpObject =  fujaba__IterSearchesToPlan.next ();

               // ensure correct type and really bound of object plan
               JavaSDM.ensure ( _TmpObject instanceof ExecuteStoryPatternOperation );
               plan = (ExecuteStoryPatternOperation) _TmpObject;


               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         // assign attribute realObj
         realObj.setBound (true);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         return null;

      }
      return plan;
   }

   private boolean minimizeCost (UMLObjectRef object , SearchOperation search , SortedSet minQueue )
   {
      boolean fujaba__Success = false;
      ExecutionPlanEngine engine = null;
      double cost = 0.0;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // search to-one link mutators from this to engine
         engine = this.getEngine ();

         // check object engine is really bound
         JavaSDM.ensure ( engine != null );


         // collabStat call
         cost = engine.getCost (search);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object object is really bound
         JavaSDM.ensure ( object != null );
         // attribute condition minSearchCost == 0
         JavaSDM.ensure ( object.getMinSearchCost () == 0 );

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         // story pattern Successor of successor
         try 
         {
            fujaba__Success = false; 

            // check object object is really bound
            JavaSDM.ensure ( object != null );
            // attribute condition minSearchCost > cost
            JavaSDM.ensure ( object.getMinSearchCost () > cost );

            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }

         if ( !( fujaba__Success ) )
         {
            return false;

         }

      }
      // story pattern Successor of successor
      try 
      {
         fujaba__Success = false; 

         // check object minQueue is really bound
         JavaSDM.ensure ( minQueue != null );
         // check object object is really bound
         JavaSDM.ensure ( object != null );
         // check link contains from minQueue to object
         JavaSDM.ensure (minQueue.contains (object));

         // destroy link contains from minQueue to object
         minQueue.remove (object);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern Successor of Successor of successor
      try 
      {
         fujaba__Success = false; 

         // check object object is really bound
         JavaSDM.ensure ( object != null );
         // assign attribute object
         object.setMinSearchCost (cost);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern Successor of Successor of Successor of successor
      try 
      {
         fujaba__Success = false; 

         // check object minQueue is really bound
         JavaSDM.ensure ( minQueue != null );
         // check object object is really bound
         JavaSDM.ensure ( object != null );
         // create link contains from minQueue to object
         minQueue.add (object);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return true;
   }

   public void mutate (ExecuteStoryPatternOperation plan )
   {
      boolean fujaba__Success = false;
      ObjectSet objects = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object plan is really bound
         JavaSDM.ensure ( plan != null );
         // search to-one link objects from plan to objects
         objects = plan.getObjects ();

         // check object objects is really bound
         JavaSDM.ensure ( objects != null );


         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         // story pattern storypatternwiththis
         try 
         {
            fujaba__Success = false; 

            // collabStat call
            this.createSpanningTree (plan, objects);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }

         return ;

      }
      // story pattern 
      try 
      {
         fujaba__Success = false; 

         // collabStat call
         getEngine ().internalError ("Plan or object set not found", null);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   private boolean processSearch (UMLObjectRef source , ObjectSet objects , Set searches , SortedSet minQueue , SearchOperation search , UMLObjectRef unboundRef )
   {
      boolean fujaba__Success = false;
      Iterator fujaba__IterObjectsToUnboundNeeds = null;
      UMLObjectRef unboundNeeds = null;
      boolean changed = false;
      Token tmpParent = null;
      Iterator fujaba__IterUnboundRefToOldSearch = null;
      Object _TmpObject = null;
      SearchOperation oldSearch = null;
      Iterator fujaba__IterOldSearchToChild = null;
      SearchOperation child = null;

      // Ensure there are no dependencies to unbound objects (multilinks could have those)
      // story pattern Successor of successor
      try 
      {
         fujaba__Success = false; 

         // check object objects is really bound
         JavaSDM.ensure ( objects != null );
         // check object search is really bound
         JavaSDM.ensure ( search != null );
         // check object source is really bound
         JavaSDM.ensure ( source != null );
         // check object unboundRef is really bound
         JavaSDM.ensure ( unboundRef != null );
         // check isomorphic binding between objects unboundRef and source
         JavaSDM.ensure ( !unboundRef.equals (source) );

         // iterate to-many link items from objects to unboundNeeds
         fujaba__Success = false;
         fujaba__IterObjectsToUnboundNeeds = objects.iteratorOfItems ();

         while ( !(fujaba__Success) && fujaba__IterObjectsToUnboundNeeds.hasNext () )
         {
            try
            {
               unboundNeeds = (UMLObjectRef) fujaba__IterObjectsToUnboundNeeds.next ();

               // check object unboundNeeds is really bound
               JavaSDM.ensure ( unboundNeeds != null );
               // check isomorphic binding between objects unboundNeeds and source
               JavaSDM.ensure ( !unboundNeeds.equals (source) );

               // check isomorphic binding between objects unboundRef and unboundNeeds
               JavaSDM.ensure ( !unboundRef.equals (unboundNeeds) );

               // check link needs from unboundNeeds to search
               JavaSDM.ensure (unboundNeeds.hasInDependentOperations (search));


               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return false;

      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // collabStat call
         changed = this.minimizeCost (unboundRef, search, minQueue);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( changed ) )
      {
         return false;

      }
      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object search is really bound
         JavaSDM.ensure ( search != null );
         // check object searches is really bound
         JavaSDM.ensure ( searches != null );
         // check object unboundRef is really bound
         JavaSDM.ensure ( unboundRef != null );
         // iterate to-many link subject from unboundRef to oldSearch
         fujaba__Success = false;
         fujaba__IterUnboundRefToOldSearch = unboundRef.iteratorOfSubjectOf ();

         while ( !(fujaba__Success) && fujaba__IterUnboundRefToOldSearch.hasNext () )
         {
            try
            {
               _TmpObject =  fujaba__IterUnboundRefToOldSearch.next ();

               // ensure correct type and really bound of object oldSearch
               JavaSDM.ensure ( _TmpObject instanceof SearchOperation );
               oldSearch = (SearchOperation) _TmpObject;

               // check isomorphic binding between objects search and oldSearch
               JavaSDM.ensure ( !search.equals (oldSearch) );

               // search to-one link children from oldSearch to tmpParent
               tmpParent = oldSearch.getParent ();

               // check object tmpParent is really bound
               JavaSDM.ensure ( tmpParent != null );

               // check isomorphic binding between objects tmpParent and oldSearch
               JavaSDM.ensure ( !tmpParent.equals (oldSearch) );

               // check isomorphic binding between objects tmpParent and search
               JavaSDM.ensure ( !tmpParent.equals (search) );


               // check link contains from searches to oldSearch
               JavaSDM.ensure (searches.contains (oldSearch));


               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         // destroy link children from tmpParent to oldSearch
         tmpParent.removeFromChildren (oldSearch);
         // destroy link contains from searches to oldSearch
         searches.remove (oldSearch);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         try 
         {
            fujaba__Success = false; 

            // check object oldSearch is really bound
            JavaSDM.ensure ( oldSearch != null );
            // check object search is really bound
            JavaSDM.ensure ( search != null );
            // check isomorphic binding between objects search and oldSearch
            JavaSDM.ensure ( !search.equals (oldSearch) );

            // iterate to-many link children from oldSearch to child
            fujaba__Success = false;
            fujaba__IterOldSearchToChild = oldSearch.iteratorOfChildren ();

            while ( fujaba__IterOldSearchToChild.hasNext () )
            {
               try
               {
                  _TmpObject =  fujaba__IterOldSearchToChild.next ();

                  // ensure correct type and really bound of object child
                  JavaSDM.ensure ( _TmpObject instanceof SearchOperation );
                  child = (SearchOperation) _TmpObject;

                  // check isomorphic binding between objects oldSearch and child
                  JavaSDM.ensure ( !oldSearch.equals (child) );

                  // check isomorphic binding between objects search and child
                  JavaSDM.ensure ( !search.equals (child) );

                  // destroy link children from child to oldSearch
                  child.setParent (null);
                  // create link children from child to search
                  child.setParent (search);


                  fujaba__Success = true;
               }
               catch ( JavaSDMException fujaba__InternalException )
               {
                  fujaba__Success = false;
               }
            }
            JavaSDM.ensure (fujaba__Success);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      return true;
   }

}


