rule AllOtherNodeToFloorRule {
// The final rule to handle creating Floor spaces, how is this different from the
//	previous three? 
	source {
			boardNode : Node { 
			boardNode.name == "BOARD"
			-children-> rowNode
		}
		
		rowNode : Node { 
			rowNode.name == "ROW"
			rowNode.index != 0
		}
		
		++ columnNode : Node { 
			columnNode.name := "COLUMN"
			++ -parentNode-> rowNode
		}
		
		leftColNode : Node { 
			leftColNode.name == "COLUMN"
			- parentNode -> rowNode			
		}
		
		topRowNode : Node { 
			topRowNode.name == "ROW"
			 - parentNode -> boardNode
		}
		
		topColNode : Node { 
			topColNode.name == "COLUMN"
			 - parentNode -> topRowNode
		} 
	}
	
	correspondence {
		boardNode <- nodeToBoard : NodeToBoard -> board
		leftColNode <- l2f : NodeToFloor -> leftNeighbor
		topColNode <- t2f : NodeToFloor -> topNeighbor
		++ columnNode <- nodeToFloor : NodeToFloor -> floor
	}
	
	target {
		board : Board { 
				-floors-> leftNeighbor
				-floors-> topNeighbor
				++ -floors-> floor
			}
			
			leftNeighbor : Floor
			
			topNeighbor : Floor
			
			++ floor : Floor { 
				++ -left-> leftNeighbor
				++ -top-> topNeighbor
			}
	
	}
	
	constraints {
		sub(floor.row, 1, topNeighbor.row)
		sub(floor.col, 1, leftNeighbor.col)
		
		eq(floor.row, rowNode.index)
		eq(floor.col, columnNode.index)
		eq(floor.row, leftNeighbor.row)
		eq(floor.col, topNeighbor.col)
		
		sub(columnNode.index, 1, leftColNode.index)
		sub(rowNode.index, 1, topRowNode.index)
		eq(topColNode.index, columnNode.index)
	}
}