<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE cheatsheet SYSTEM "cheatSheetFormat.dtd">
<cheatsheet title="Chapter 2: SDM">
	<intro>
    	<description>
         In this Chapter, you'll learn about Story Driven Modeling (SDM). For the
         interested reader, the content of this chapter is based on Part III of the 
         eMoflon handbook.<br/>
         
         <br/>
         To briefly explain, SDMs implement unidirectional model transformations. They're
         a combination of simplified activity diagrams and graph pattern rules used to
         describe behaviour. In other words, SDMs can be used to specify a language's dynamic semantics.
         <br/>
         
         <br/>
         We'll start the chapter by modeling what <b>Board</b> can do, specifically how it
         will handle clearing all Floors of their Figures, and selecting Figures for
         action. We'll then proceed to describe how each Figure moves. Let's begin!
      </description>
	</intro>
<item 
		title="Step 1 - Figure.moveTo()">
		<description>
      	 To ease ourselves into SDM patterns, let's update the moveTo method in 
      	 <b>Figure</b> by implementing a simple control flow:<br/>
         
         <br/>
         <b> moveTo(floor : Floor) : void { </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160; if [moveFigure] </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160; </b><br/>
         <b> } </b>  <br/>
                            
         <br/>
         This method invokes the 'moveFigure pattern', which handles actual details
         of the method in a separate file containing the pattern.
         We consider this pattern
         to be the fundamental movement of any figure type, to be customized for
         each figure's specific actions (such as allowing the Admin to push
         Servers, or making Wall immobile).
         <br/>
         
         <br/>
         Save the file. Some errors should immediately appear in the 'Problems' tab 
         below the editor - MOSL complains that it is unable to find the pattern file.
         Select this error, and press <b>Ctrl + 1</b> to invoke a "Quick Fix" dialogue.
         
         <br/>
         This window offers to generate the missing file for you. Select the fix, then press 
         finish. The new file should open automatically in the editor. We'll complete it in 
         the next step.
      </description>
	<action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step01"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage"
      param3 = "nobuild"/>>
   </item>
   
<item
	  title="Step 2 - moveFigure.pattern">
      <description>
    	Before editing your pattern, take a look at your Package Explorer. When you
    	first created the <b>SokobanLanguage</b> EPackage, a <b>_patterns</b> folder was 
    	automatically created with it. This folder will contain subfolders for each
    	class that contains a method with a pattern, which will, in turn, store the
    	actual pattern file. <br/>
    	
    	<br/>
		A pattern is basically a set of constraints. It defines various object and link
		variables, and each variable scope can state constraints on its attributes and references
		as defined in its class. Add the following object variables:
		<br/>
		
		<br/><b> oldFloor : Floor</b><br/>

		<br/><b> @floor : Floor </b><br/>
		
		<br/>
		The first is a temporary free object variable. The second variable is bound (indicated by the "@" sign)
		the parameter value 'floor,' which represents 
		the target floor space the figure is trying to move to.
		<br/>
		
		<br/>
		Next, create an object variable that matches to the invoking figure:<br/>
		
		<br/><b> @this : Figure</b><br/>
		
		<br/>
		Let's add a scope to this variable to handle the 'floor' reference connecting it some
		valid Floor instance. Update '@this' until it resembles:<br/>
		
		<br/>
		<b> @this : Figure { </b><br/>
		<b> &#160;&#160;&#160;&#160;&#160;--  -floor-> oldFloor </b><br/>
		<b> &#160;&#160;&#160;&#160;&#160;++  -floor-> floor </b><br/>
		<b> } </b><br/>
		
		<br/>
		As you can see, we REMOVE the reference to the Figure's current Floor, and ADD a new reference to
		the target floor.<br/>
		
		<br/>
		Press "Click to Perform" to load a commented 'moveFigure.pattern' into your workspace which will
		explain patterns and their variables in more detail. Otherwise, save, build, and proceed to Step 3.
	</description>
	 <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step02"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Figure/moveTo"/>
   </item>
<item
         title="Step 3 - Board.floorSelected()"
         validation="chapter2;1">
      <description>
      	Even though we&apos;ve implemented how a Figure will move between floors, we haven&apos;t implemented the 
      	<b>floorSelected</b> method of our <b>Board</b> so that the game actually &apos;activates&apos;
      	the relevant Figure.<br/>
      	
      	<br/>
      	This method must first check to see if a Figure has been selected. If one has, move that figure 
      	to the target via the moveTo method we established in Step 1 and 2. 
      	Otherwise, if a Figure has not yet been selected, select it! <br/>
		
		<br/>
		This method will need two patterns - one to check for a Figure, and one to select a Figure.
		It will also need an if/else control flow.<br/>
		
		<br/>
		Open &apos;Board&apos; and implement the &apos;floorSelected&apos; method as described below. Don&apos;t
		forget about eMoflon&apos;s auto-completion feature! You can use it here to generate a template.<br/>
		
		<br/>
		<b> floorSelected(floor : Floor) : void {</b><br/>
		<b>       if [checkSelected] { </b><br/>
		<b>          &lt;@alreadySelectedFigure.moveTo($floor)&gt; </b><br/>
		<b>       } else { </b><br/>
		<b>          if [selectFigure] { </b><br/>
		<b>               return</b><br/>
		<b>          } </b><br/>
		<b>       } </b><br/>
		<b>       return </b><br/>
		<b> } </b><br/>
		
		<br/>
		As you can see, the moveTo method call is NOT implemented as a pattern. In fact, MOSL doesn&apos;t 
		allow direct method calls. Instead, it uses statement nodes and syntax similar to Java to 
		permit communication between classes.<br/>
		
		<br/>
		Save your project and build the two new patterns or press <b>Click to perform</b> below to 
		load an updated and commented &apos;Board.eclass&apos; file with more details about method control and 
		statement nodes. Don&apos;t worry about the error message that remains after creating the patterns 
		- the next step will take care of this.
   	</description>
	<action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step03"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage"
      param3 = "nobuild"/>>
   </item>
<item
         title="Step 4 - checkSelected.pattern">
      <description>
		Open <b>checkSelected.pattern</b>. This is the pattern that checks to see if a reference
		to a Figure already exists. You'll need two object variables, one for the figure, and one
		for the invoking board. Complete your pattern as written below:<br/>
		
		<br/> <b>alreadySelectedFigure : Figure </b><br/>

		<br/><b>@this : Board { </b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160;-- -selectedFigure-> alreadySelectedFigure </b><br/>
		<b>}</b><br/>
		
		<br/>
		This pattern attempts to remove the 'selectedFigure' reference to a Figure. If this fails
		(i.e., if there is no reference to remove), then no figure has obviously been selected, and the
		if/else in board.fieldSelected will proceed to the second pattern. If this passes, the
		control flow proceeds to the statement node.
  </description>
	 <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step04"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Board/floorSelected"
      param3 = "nobuild"/>>
   </item>
<item
     title="Step 5 - selectFigure.pattern">
     <description>
   		Given that this pattern is reached when no figure is currently active, we need to set
   		the 'selectedFigure' reference for Board, determining the relevant Figure instance
   		by matching the 'figure' reference for Floor. Complete your pattern as described below:
   		<br/>
   		
		<br/><b> @floor : Floor { </b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; -figure-> figure </b><br/>
		<b> } </b>
		<br/><br/>
		<b> @this : Board { </b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; ++ -selectedFigure-> figure </b><br/>
		<b> } </b><br/>
		
		<br/><b>figure : Figure </b><br/>
		
		<br/>
		That's everything you needed for Board.fieldSelected(floor:Floor)! Save and build your
		project now to confirm everything has been done correctly.
     </description>
      <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step05"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Board/floorSelected"/>>
</item>
<item
     	title="Step 6 - Board.clear()"
     	validation="chapter2;5">
     <description>
    	Now let take care of the <b>clear</b> method in <b>Board</b>. This will reset the game space, 
    	removing all the <b>figures</b> from every <b>Floor</b>. To guarantee each Floor instance is
    	reached, this control flow for this method must be a for/Each loop as described below: <br/>
		
		<br/>
		<b> clear() : void { </b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; forEach [bindFloor] {</b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if [removeFigure] </b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; } </b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; return </b><br/>
		<b> } </b><br/>
		
		<br/>
		Both patterns are very short, the first matching to every floor instance, and the latter completely
		removing a Figure from the game.
	</description>
	<action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
    	required = "false"
    	param1 = "resources/tutorial-Sokoban/Chapter2/Step06"
    	param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage"
    	param3 = "nobuild"/>>
</item>
<item
     title="Step 7 - bindFloor.pattern">
     <description>
    	This pattern intends to bind every Floor element in the 'floors' container reference, which will
    	then become the invoking this element in the second pattern, 'removeFigure.' Complete 'bindFloor'
    	as follows:<br/>
		
		<br/>
		<b>@this : Board {</b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; -floors-> floor </b><br/>
		<b> } </b>
		<br/><br/>
		<b> floor : Floor </b>
	</description>
	 <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step07"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Board/clear"
      param3 = "nobuild"/>>
</item>
<item
     title="Step 8 - removeFigure.pattern">
     <description>
     	As the name suggest, this pattern intends to remove a Figure on any Floor space. This isn&apos;t as simple 
     	as just removing the reference between Floor and Figure (and vice versa) however. We also
     	need to completely remove the active Figure object variable from the game instance! Complete the pattern
     	as follows:<br/>
		
		<br/>
		<b>@floor : Floor {</b><br/>
		<b>	&#160;&#160;&#160;&#160;&#160; -figure-&gt; figure</b><br/>
		<b>}</b>
		<br/><br/>
		<b>-- figure : Figure </b><br/>
		
		<br/>
		That's everything we need to implement the Board's behaviour of clearing its floors of all their figures! Save and build
		your project.
	</description>
	<action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step08"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Board/clear"/>>
</item>
<item
      title="Step 9 - Modifying 'Figure.moveTo()' ">
   <description>
        Whoo, you've already done a fair bit of work, setting up the framework for the game: moving, 
        activating, and clearing Figures. Let's finally start implementing how each Figure 
        type will uniquely move, the visible behaviour for the game.<br/>
        
        <br/>
        First however, have you experimented with the GUI yet, to see how the moveTo method 
        works? Did you notice that if you move one figure onto other, such as an Admin onto 
        a Server, the Server disappears? This is a flaw in our current (fundamental) moveTo 
        implementation. We need to add some sort of check directly to the pattern scope to
        make sure the target space isn't taken.<br/>
        
        <br/>
        To be precise, what we need is a Negative Application Constraint (NAC). For more details, 
        please refer to Part III, Section 8.
        <br/>
        
        <br/>
        Add the following to <b>moveFigure.pattern</b>:<br/>
        
        <br/>
        <b> ! occupyingFigure : Figure { </b><br/>
        <b> &#160;&#160;&#160;&#160;&#160; -floor-> Floor </b><br/>
        <b> } </b><br/>
        
        <br/>
        This NAC states that if any other Figure already on (i.e., connected to) our bound floor object variable, 
        the pattern is invalid and must fail. Save, build, and run the GUI once again to confirm the update.
        <br/>
        
        <br/>
        <b> Note:</b> You may also press <b>Click to perform </b> below to load a commented
        pattern file into your workspace with more explanations.
   </description>
   <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
         required = "false"
      param1 = "resources/tutorial-Sokoban/Chapter2/Step09"
      param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Figure/moveTo"/>
</item>
<item
     title="Step 10 - Keeping figures still"
     validation="chapter2;10">
     <description>
     	Now we can specify the special ways in which Admin, Server, Wall, and Goal will behave.
     	The fundamental Figure implementation currently states that every figure can move anywhere,
     	except onto another Figure. We want to modify this so Goal, Wall, and Server may never move
     	on their own (later, we'll modify Server so that it may be pushed by a Server). 
     	To start, open <b>Goal</b>, and override moveTo as follows:<br/>
     	
     	<br/>
     	<b> moveTo(floor : Floor) : void { </b><br/>
     	<b> &#160;&#160;&#160;&#160;&#160; return </b><br/>
     	<b> } </b><br/>
     	
     	<br/>
     	By removing the pattern implementation, there is simply nothing to do when the GUI
     	attempts to move a Goal figure directly and so nothing happens.<br/>
     	
     	<br/>
     	What about the Wall and Server figures? They should have similar overrides, right? In fact,
     	each of these will behave the same way, so let's refactor these classes so that a 
     	Wall is a special type of Goal (a non-winning block), and a Server is a special type
     	of Wall (an obstacle the Admin can push out of the way). Therefore, update each
     	class as follows:
     	
     	<br/><b> class Wall extends Goal { ... }</b><br/>
     	
     	<br/><b> class Server extends Wall { ... }</b>
    </description>
	<action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
    	required = "false"
    	param1 = "resources/tutorial-Sokoban/Chapter2/Step10"
    	param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage"/>>
</item>
<item
      title="Step 11 - Moving Servers"
      validation="chapter2;12">
      <description>
         Let's finish our game by specifying the behaviour of our last remaining Figure, Admin.
         Currently, it can move from any floor space, to any other floor (given that its 
         not occupied). Our plan is to have Admin 'land' on a Server and push it in the 
         same direction. But how can we get this direction, if Admin can come from anywhere? 
         Let's implement one push direction first, and base the others on that.<br/>
         
         <br/>
         Open <b>Admin.eclass</b> and add the following:<br/>
         
         <br/>
         <b> moveTo(floor : Floor) : void { </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160; if ! [pushDown] { </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if [moveFigure] { </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160; } </b><br/>
         <b> &#160;&#160;&#160;&#160;&#160; return </b><br/>
         <b> } </b><br/>
         
         <br/>
         This control states that if Admin is not able to move some server, move just the Admin
         according to our fundamental rules.<br/>
         
         <br/>
         Before moving on, be sure to save the file. You'll notice that an error will appear saying
         MOSL can't find either of the pushDown or moveFigure patterns, despite having created moveTo
         in Figure.eclass. Unfortunately, MOSL doesn't permit super access to a parent pattern, so 
         you'll need to copy and paste this pattern into the same folder as pushDown.
      </description>
      <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
    	required = "false"
    	param1 = "resources/tutorial-Sokoban/Chapter2/Step11"
    	param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage"/>>
   </item>
   <item
         title="Step 12 - pushDown.pattern">
      <description>
         Open <b>pushDown.pattern</b>, and add the following:<br/>
         
         <br/>
         <b> oldFloor : Floor { </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; -bottom-> floor </b> <br/>
		 <b> } </b> <br/>
		 
		 <br/>
		 <b> @floor : Floor { </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; -bottom-> neighbor </b> <br/>
		 <b> } </b><br/>
		 
		 <br/>
		 <b> @this : Figure { </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; -- -floor-> oldFloor </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; ++ -floor-> floor </b> <br/>
		 <b> } </b> <br/>
		 
		 <br/>
		 <b> server : Server { </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; -- -floor-> floor </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; ++ -floor-> neighbor </b> <br/>
		 <b> } </b> <br/>
		 
		 <br/>
		 <b> neighbor : Floor </b> <br/>
		 
		 <br/>
		 <b> ! noWall : Wall { </b> <br/>
		 <b> &#160;&#160;&#160;&#160;&#160; -floor-> neighbor </b> <br/>
		 <b> } </b> <br/>
		 
		 <br/>
		 To explain, imagine three squares lined up vertically. 'oldFloor' is Admin's current position at the
		 top or the column. The Server is directly below it on 'floor.' '@this' moves our Admin into the
		 Server's current position, while 'server' shifts to the next Floor directly below, given that the NAC
		 succeeds. By setting the NAC to type Wall, we permit server to shift onto a Goal space (Wall's parent
		 class), but block 'server' from moving onto either a Wall or other Server space. We could have 
		 included a second NAC to prevent 'server' from moving onto an Admin figure, but we're assuming this
		 is a one player game, and so that situation will never arise.
      </description>
      <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
    	required = "false"
    	param1 = "resources/tutorial-Sokoban/Chapter2/Step12"
    	param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage/_patterns/Admin/moveTo"/>>
   </item>
   <item
         title="Step 13 - Finishing up!">
      <description>
         Switch back to <b>Admin.eclass</b>, and update the control flow as described below:<br/>
         
         <br/>
         <b> if ! [pushDown] { </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160; if ! [pushUp] { </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ! [pushLeft] { </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
         if ! [pushRight] { </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
         &#160;&#160;&#160;&#160;&#160; if [moveFigure] { </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
         &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return  </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
         &#160;&#160;&#160;&#160;&#160;  } </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </b> <br/>
         <b> &#160;&#160;&#160;&#160;&#160; } </b> <br/>
         <b> } </b> <br/>
         <b> return </b> <br/>
         
         <br/>
         Use the Quick Fix dialogue to create each of the push patterns. You can copy and paste your work
         from 'pushDown,' but be sure to change the references in 'oldFloor' and '@floor' to match the
         required reference. It won't take long - you can use the auto-complete feature for help!
         Enter '->' then hit <b>ctrl + space</b> to load a list of valid reference (as defined in 
         Floor.eclass).<br/>
      </description>
      <action class = "org.moflon.tutorial.actions.CopyResourceToProject" pluginId = "org.moflon.CheatSheetTutorial"
    	required = "false"
    	param1 = "resources/tutorial-Sokoban/Chapter2/Step13"
    	param2 = "SokobanTutorial/MOSL/MyWorkingSet/SokobanLanguage"/>>
   </item>
   <item
         title="Step 14 - Playing with the GUI"
         validation="chapter2;14">
      <description>
      	 Great work! If you've done everything correctly up to this point, your game is now complete, and
         your GUI should now be fully functional! Try building and saving different levels - you'll be able
         to use these in a different way in Chapter 3.<br/>
         
         <br/>
         If your figures aren't moving as expected (such as Walls being able to move, or an Admin unable to 
         push a Server), review the previous steps carefully and confirm your work with the validation checks, 
         if you haven't been doing so as you went along. Otherwise, have fun!
      </description>
   </item>
   <item
         title="End of Chapter 2">
      <description>
         Great work! You have now learnt how to implement a model's dynamic semantics, specifying how
         each class may behave. As we mentioned in Step 15, you'll be able to use any unique model you
         save in the next chapter, where we transform them to and from a textual syntax. In fact, 
         we'll direct you towards a site where you can submit and download challenging Sokoban levels
         from other users that are compatible with your game!<br/>
         
         <br/>
         Before leaving, are there any other Figures you can think of that might be fun to include in
         your game? Is there any other behaviour you would like to implement for specific Figure
         types (such as preventing an Admin from moving OVER a Server or Wall)? We invite you to
         experiment with our MOSL language and SDMs.<br/>
         
         <br/>
         Don't forget to visit our project website, <b>eMoflon.org</b> for the official eMoflon handbook
         which covers SDM patterns in detail, including pattern variables, control flow, statement nodes,
         and NACs. If you've had problems with this chapter, or have a few ideas on how we can improve
         this tutorial, feel free to contact us at <b>contact@moflon.org</b>.
      </description>
   </item>
</cheatsheet>
