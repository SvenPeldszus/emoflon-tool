rule BoardNodeToBoardRule {

// In this rule we will build a board with only one floor in the upper left corner, and
// 	we'll define this place as the origin (0,0). Later rules will then be able to 'append'
// 	further Floor instances to the origin until the entire Board is created. Therefore,
//	our source scope will model and match MocaTree node instances, and the target scope
//	will mode the game's Board and Floor instances. Given that this is the very first 
//	rule to be executed in our entire transformation, every element will be 'green' or
// 	'created.' Future rules will include 'black' elements, which demand the relevant
//	instance to already exist. These allow us to force rules to be executed in a 
//	certain order.

// You are strongly encouraged to read the first page of each section in Part IV of the eMoflon
//	handbook for more details on the goals of TGGs, the purposes of each scope, and 
//	detailed specifics of the source, target, and correspondence components of the 
// 	Graph Triple that will be built up in each rule we specfiy in the scopes below.


	source {
		// This matches to a generated MocaTree instance as:
		// BOARD_SPEC
		//	 DIMENSIONS
		//		WIDTH 	(index 0, Node n)
		//		HEIGHT 	(index 1, Node n)
		//	 BOARD
		//		ROW	 (index 0)
		//		  COLUMN* (index 0, Node figure?)
	
		// Usually, the root of a MocaTree instance is a folder containing other
		// 	(sub) folders and files, representing an actual filesytem structure.
		// 	In this example however, we only parse one .sok file, so our root object
		// 	is a file containing one Node. You'll notice that every Node only has two
		// 	values: an arbitary STRING (name), and EInt (index). These are why several
		// 	nodes are required to represent a single object

		++ file : File { 
			++ -rootNode-> boardSpecNode
		}
		
		++ boardSpecNode : Node { 
			boardSpecNode.name := "BOARD_SPEC"
			++ -children-> boardNode
			++ -children-> dimensionNode
		}

		// The following five nodes are required to specify the height and width
		//	dimensions of a Board. To avoid accidentally switching the row and col
		//	sizes, the nodes use attribute constraints to bind their index to the
		//	correct 0 or 1 position (as shown in the tree description at the start of
		//	this scope.) As such, they need a second Node to store the actual EInt 'n'
		//	size.

		++ dimensionNode : Node { 
			dimensionNode.name := "DIMENSIONS"
			dimensionNode.index := 0
			++ -children-> rowsNode
			++ -children-> colsNode
		}
		
		++ rowsNode : Node { 
			rowsNode.name := "ROWS"
			rowsNode.index := 0
			++ -children-> rowCountNode
		}
		
		++ colsNode : Node { 
			colsNode.name := "COLS"
			colsNode.index := 1
		    ++ -children-> columnCountNode
		}
		
		++ rowCountNode : Node { 
			rowCountNode.index := 0
			// rowCountNode.name is the HEIGHT of board
		}
		
		++ columnCountNode : Node { 
		   columnCountNode.index := 0
		   // columnCountNode.name is the WIDTH of board
		 }
		
		
		// Three final nodes are required to contain the actual Floors of Board.
		// 	They contain an unknown number of ROW nodes, and each row node has an
		//	n index value corresponding to the row number it represents, and contains
		//	a child node which forms the columns. Similar to row numbers, a column
		// 	node's index represents the column number it's part of. Columns also
		//	contain nodes represening the Figure on their Floor space, but we'll
		// 	handle these in a later rule.
		
		++ boardNode : Node { 
			boardNode.name := "BOARD"
			boardNode.index := 1
			 ++ -children-> topRowNode
		}
		
		++ topRowNode : Node { 
			 topRowNode.name := "ROW"
			 topRowNode.index := 0
			 ++ -children-> topRowLeftColumnNode
		 }

		++ topRowLeftColumnNode : Node { 
			 topRowLeftColumnNode.name := "COLUMN"
			 topRowLeftColumnNode.index := 0
		 }
		 
	}
	
	
	
	// In the correspondence scope below, we declare instances of the link metamodel
	//	connecting elements using types defined in the schema. You can create as many
	//	links as you like between related objects (in the relevant rule) to ensure they
	//	remain consistent with one another! 
	correspondence {
		
	}

	// This target scope will define whatever objects we need from 'SokobanLanguage' in
	//	order to create a valid Board instance
	target {
		
	}
	
	
	// Finally, correspondence constraints ensure that the involved attributes remain
	// 	equvalent in both the target and source domains.
	constraints {[
		
	]}
}