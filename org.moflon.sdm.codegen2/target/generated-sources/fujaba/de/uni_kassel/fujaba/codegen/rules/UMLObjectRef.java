/*
 * generated by Fujaba - CodeGen2
 */
package de.uni_kassel.fujaba.codegen.rules;
import java.util.Collections;
import java.util.Iterator;
import java.util.Set;

import de.uni_kassel.features.ReferenceHandler; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.features.annotation.util.Property; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.fujaba.codegen.textlang.UMLSymTabContext;
import de.uni_kassel.fujaba.codegen.textlang.UMLTextLangInfo;
import de.uni_paderborn.fujaba.uml.behavior.UMLObject;
import de.upb.tools.fca.FEmptyIterator;
import de.upb.tools.fca.FHashSet; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDM; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDMException;


public class UMLObjectRef extends Object
{


   /**
    * <pre>
    *           0..n     needs     0..n
    * UMLObjectRef ------------------------- Operation
    *           needs               dependentOperations
    * </pre>
    */
   public static final String PROPERTY_DEPENDENT_OPERATIONS = "dependentOperations";

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS, partner = Operation.PROPERTY_NEEDS, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<Operation> dependentOperations;

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public Set<? extends Operation> getDependentOperations()
   {
      return ((this.dependentOperations == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.dependentOperations));
   }

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public boolean addToDependentOperations (Operation value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.dependentOperations == null)
         {
            this.dependentOperations = new FHashSet<Operation> ();

         }
      
         changed = this.dependentOperations.add (value);
         if (changed)
         {
            value.addToNeeds (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public UMLObjectRef withDependentOperations (Operation value)
   {
      addToDependentOperations (value);
      return this;
   }

   public UMLObjectRef withoutDependentOperations (Operation value)
   {
      removeFromDependentOperations (value);
      return this;
   }


   public boolean removeFromDependentOperations (Operation value)
   {
      boolean changed = false;

      if ((this.dependentOperations != null) && (value != null))
      {
      
         changed = this.dependentOperations.remove (value);
         if (changed)
         {
            value.removeFromNeeds (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public void removeAllFromDependentOperations (){
   
      Operation tmpValue;
      Iterator<? extends Operation> iter = this.iteratorOfDependentOperations ();
      while (iter.hasNext ())
      {
         tmpValue = (Operation) iter.next ();
         this.removeFromDependentOperations (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public boolean hasInDependentOperations (Operation value)
   {
      return ((this.dependentOperations != null) &&
              (value != null) &&
              this.dependentOperations.contains (value));
   }

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public Iterator<? extends Operation> iteratorOfDependentOperations ()
   {
      return ((this.dependentOperations == null)
              ? FEmptyIterator.<Operation>get ()
              : this.dependentOperations.iterator ());
   }

   @Property( name = PROPERTY_DEPENDENT_OPERATIONS )
   public int sizeOfDependentOperations ()
   {
      return ((this.dependentOperations == null)
              ? 0
              : this.dependentOperations.size ());
   }

   /**
    * <pre>
    *           0..1     items     0..n
    * UMLObjectRef ------------------------- ObjectSet
    *           items               list
    * </pre>
    */
   public static final String PROPERTY_LIST = "list";

   @Property( name = PROPERTY_LIST, partner = ObjectSet.PROPERTY_ITEMS, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<ObjectSet> list;

   @Property( name = PROPERTY_LIST )
   public Set<? extends ObjectSet> getList()
   {
      return ((this.list == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.list));
   }

   @Property( name = PROPERTY_LIST )
   public boolean addToList (ObjectSet value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.list == null)
         {
            this.list = new FHashSet<ObjectSet> ();

         }
      
         changed = this.list.add (value);
         if (changed)
         {
            value.addToItems (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_LIST )
   public UMLObjectRef withList (ObjectSet value)
   {
      addToList (value);
      return this;
   }

   public UMLObjectRef withoutList (ObjectSet value)
   {
      removeFromList (value);
      return this;
   }


   public boolean removeFromList (ObjectSet value)
   {
      boolean changed = false;

      if ((this.list != null) && (value != null))
      {
      
         changed = this.list.remove (value);
         if (changed)
         {
            value.removeFromItems (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_LIST )
   public void removeAllFromList (){
   
      ObjectSet tmpValue;
      Iterator<? extends ObjectSet> iter = this.iteratorOfList ();
      while (iter.hasNext ())
      {
         tmpValue = (ObjectSet) iter.next ();
         this.removeFromList (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_LIST )
   public boolean hasInList (ObjectSet value)
   {
      return ((this.list != null) &&
              (value != null) &&
              this.list.contains (value));
   }

   @Property( name = PROPERTY_LIST )
   public Iterator<? extends ObjectSet> iteratorOfList ()
   {
      return ((this.list == null)
              ? FEmptyIterator.<ObjectSet>get ()
              : this.list.iterator ());
   }

   @Property( name = PROPERTY_LIST )
   public int sizeOfList ()
   {
      return ((this.list == null)
              ? 0
              : this.list.size ());
   }

   public static final String PROPERTY_MIN_SEARCH_COST = "minSearchCost";

   @Property( name = PROPERTY_MIN_SEARCH_COST, kind = ReferenceHandler.ReferenceKind.ATTRIBUTE )
   private double minSearchCost;

   @Property( name = PROPERTY_MIN_SEARCH_COST )
   public void setMinSearchCost (double value)
   {
      this.minSearchCost = value;
   }

   public UMLObjectRef withMinSearchCost (double value)
   {
      setMinSearchCost (value);
      return this;
   }

   @Property( name = PROPERTY_MIN_SEARCH_COST )
   public double getMinSearchCost ()
   {
      return this.minSearchCost;
   }

   /**
    * <pre>
    *           0..1     ref     0..1
    * UMLObjectRef ------------------------> UMLObject
    *           uMLObjectRef               ref
    * </pre>
    */
   public static final String PROPERTY_REF = "ref";

   @Property( name = PROPERTY_REF, kind = ReferenceHandler.ReferenceKind.TO_ONE,
         adornment = ReferenceHandler.Adornment.NONE)
   private UMLObject ref;

   @Property( name = PROPERTY_REF )
   public boolean setRef (UMLObject value)
   {
      boolean changed = false;

      if (this.ref != value)
      {
      
         UMLObject oldValue = this.ref;
         this.ref = value;
         changed = true;
      
      }
      return changed;
   }

   @Property( name = PROPERTY_REF )
   public UMLObjectRef withRef (UMLObject value)
   {
      setRef (value);
      return this;
   }

   public UMLObject getRef ()
   {
      return this.ref;
   }

   /**
    * <pre>
    *           0..1     subject     0..n
    * UMLObjectRef ------------------------- ObjectOperation
    *           subject               subjectOf
    * </pre>
    */
   public static final String PROPERTY_SUBJECT_OF = "subjectOf";

   @Property( name = PROPERTY_SUBJECT_OF, partner = ObjectOperation.PROPERTY_SUBJECT, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<ObjectOperation> subjectOf;

   @Property( name = PROPERTY_SUBJECT_OF )
   public Set<? extends ObjectOperation> getSubjectOf()
   {
      return ((this.subjectOf == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.subjectOf));
   }

   @Property( name = PROPERTY_SUBJECT_OF )
   public boolean addToSubjectOf (ObjectOperation value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.subjectOf == null)
         {
            this.subjectOf = new FHashSet<ObjectOperation> ();

         }
      
         changed = this.subjectOf.add (value);
         if (changed)
         {
            value.setSubject (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SUBJECT_OF )
   public UMLObjectRef withSubjectOf (ObjectOperation value)
   {
      addToSubjectOf (value);
      return this;
   }

   public UMLObjectRef withoutSubjectOf (ObjectOperation value)
   {
      removeFromSubjectOf (value);
      return this;
   }


   public boolean removeFromSubjectOf (ObjectOperation value)
   {
      boolean changed = false;

      if ((this.subjectOf != null) && (value != null))
      {
      
         changed = this.subjectOf.remove (value);
         if (changed)
         {
            value.setSubject (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SUBJECT_OF )
   public void removeAllFromSubjectOf (){
   
      ObjectOperation tmpValue;
      Iterator<? extends ObjectOperation> iter = this.iteratorOfSubjectOf ();
      while (iter.hasNext ())
      {
         tmpValue = (ObjectOperation) iter.next ();
         this.removeFromSubjectOf (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_SUBJECT_OF )
   public boolean hasInSubjectOf (ObjectOperation value)
   {
      return ((this.subjectOf != null) &&
              (value != null) &&
              this.subjectOf.contains (value));
   }

   @Property( name = PROPERTY_SUBJECT_OF )
   public Iterator<? extends ObjectOperation> iteratorOfSubjectOf ()
   {
      return ((this.subjectOf == null)
              ? FEmptyIterator.<ObjectOperation>get ()
              : this.subjectOf.iterator ());
   }

   @Property( name = PROPERTY_SUBJECT_OF )
   public int sizeOfSubjectOf ()
   {
      return ((this.subjectOf == null)
              ? 0
              : this.subjectOf.size ());
   }

   /**
    * <pre>
    *           0..1     subjectObject     0..n
    * UMLObjectRef ------------------------- UMLSymTabContext
    *           subjectObject               symTabContexts
    * </pre>
    */
   public static final String PROPERTY_SYM_TAB_CONTEXTS = "symTabContexts";

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS, partner = UMLSymTabContext.PROPERTY_SUBJECT_OBJECT, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<UMLSymTabContext> symTabContexts;

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public Set<? extends UMLSymTabContext> getSymTabContexts()
   {
      return ((this.symTabContexts == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.symTabContexts));
   }

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public boolean addToSymTabContexts (UMLSymTabContext value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.symTabContexts == null)
         {
            this.symTabContexts = new FHashSet<UMLSymTabContext> ();

         }
      
         changed = this.symTabContexts.add (value);
         if (changed)
         {
            value.setSubjectObject (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public UMLObjectRef withSymTabContexts (UMLSymTabContext value)
   {
      addToSymTabContexts (value);
      return this;
   }

   public UMLObjectRef withoutSymTabContexts (UMLSymTabContext value)
   {
      removeFromSymTabContexts (value);
      return this;
   }


   public boolean removeFromSymTabContexts (UMLSymTabContext value)
   {
      boolean changed = false;

      if ((this.symTabContexts != null) && (value != null))
      {
      
         changed = this.symTabContexts.remove (value);
         if (changed)
         {
            value.setSubjectObject (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public void removeAllFromSymTabContexts (){
   
      UMLSymTabContext tmpValue;
      Iterator<? extends UMLSymTabContext> iter = this.iteratorOfSymTabContexts ();
      while (iter.hasNext ())
      {
         tmpValue = (UMLSymTabContext) iter.next ();
         this.removeFromSymTabContexts (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public boolean hasInSymTabContexts (UMLSymTabContext value)
   {
      return ((this.symTabContexts != null) &&
              (value != null) &&
              this.symTabContexts.contains (value));
   }

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public Iterator<? extends UMLSymTabContext> iteratorOfSymTabContexts ()
   {
      return ((this.symTabContexts == null)
              ? FEmptyIterator.<UMLSymTabContext>get ()
              : this.symTabContexts.iterator ());
   }

   @Property( name = PROPERTY_SYM_TAB_CONTEXTS )
   public int sizeOfSymTabContexts ()
   {
      return ((this.symTabContexts == null)
              ? 0
              : this.symTabContexts.size ());
   }

   public String toString ()
   {
      boolean fujaba__Success = false;
      UMLObject orig = null;
      String objName = null;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // search to-one link ref from this to orig
         orig = this.getRef ();

         // check object orig is really bound
         JavaSDM.ensure ( orig != null );


         // collabStat call
         objName = orig.getObjectName();
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return objName + " mincost: " + getMinSearchCost();
   }

   /**
    * <pre>
    *           0..n     needs     0..n
    * UMLObjectRef ------------------------- UMLTextLangInfo
    *           needs               usedByTextLangInfo
    * </pre>
    */
   public static final String PROPERTY_USED_BY_TEXT_LANG_INFO = "usedByTextLangInfo";

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO, partner = UMLTextLangInfo.PROPERTY_NEEDS, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<UMLTextLangInfo> usedByTextLangInfo;

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public Set<? extends UMLTextLangInfo> getUsedByTextLangInfo()
   {
      return ((this.usedByTextLangInfo == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.usedByTextLangInfo));
   }

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public boolean addToUsedByTextLangInfo (UMLTextLangInfo value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.usedByTextLangInfo == null)
         {
            this.usedByTextLangInfo = new FHashSet<UMLTextLangInfo> ();

         }
      
         changed = this.usedByTextLangInfo.add (value);
         if (changed)
         {
            value.addToNeeds (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public UMLObjectRef withUsedByTextLangInfo (UMLTextLangInfo value)
   {
      addToUsedByTextLangInfo (value);
      return this;
   }

   public UMLObjectRef withoutUsedByTextLangInfo (UMLTextLangInfo value)
   {
      removeFromUsedByTextLangInfo (value);
      return this;
   }


   public boolean removeFromUsedByTextLangInfo (UMLTextLangInfo value)
   {
      boolean changed = false;

      if ((this.usedByTextLangInfo != null) && (value != null))
      {
      
         changed = this.usedByTextLangInfo.remove (value);
         if (changed)
         {
            value.removeFromNeeds (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public void removeAllFromUsedByTextLangInfo (){
   
      UMLTextLangInfo tmpValue;
      Iterator<? extends UMLTextLangInfo> iter = this.iteratorOfUsedByTextLangInfo ();
      while (iter.hasNext ())
      {
         tmpValue = (UMLTextLangInfo) iter.next ();
         this.removeFromUsedByTextLangInfo (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public boolean hasInUsedByTextLangInfo (UMLTextLangInfo value)
   {
      return ((this.usedByTextLangInfo != null) &&
              (value != null) &&
              this.usedByTextLangInfo.contains (value));
   }

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public Iterator<? extends UMLTextLangInfo> iteratorOfUsedByTextLangInfo ()
   {
      return ((this.usedByTextLangInfo == null)
              ? FEmptyIterator.<UMLTextLangInfo>get ()
              : this.usedByTextLangInfo.iterator ());
   }

   @Property( name = PROPERTY_USED_BY_TEXT_LANG_INFO )
   public int sizeOfUsedByTextLangInfo ()
   {
      return ((this.usedByTextLangInfo == null)
              ? 0
              : this.usedByTextLangInfo.size ());
   }

   public void removeYou()
   {
      this.removeAllFromDependentOperations ();
      this.removeAllFromList ();
      this.setRef (null);
      this.removeAllFromSubjectOf ();
      this.removeAllFromSymTabContexts ();
      this.removeAllFromUsedByTextLangInfo ();
   }
}


