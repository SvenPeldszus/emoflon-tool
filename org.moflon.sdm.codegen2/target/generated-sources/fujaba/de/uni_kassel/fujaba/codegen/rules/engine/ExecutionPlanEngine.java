/*
 * generated by Fujaba - CodeGen2
 */
package de.uni_kassel.fujaba.codegen.rules.engine;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import de.uni_kassel.features.ReferenceHandler; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.features.annotation.util.Property; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.fujaba.codegen.engine.OperationSorter;
import de.uni_kassel.fujaba.codegen.engine.TokenTreeMutatorEngine;
import de.uni_kassel.fujaba.codegen.rules.ExecuteStoryPatternOperation;
import de.uni_kassel.fujaba.codegen.rules.Token;
import de.uni_paderborn.fujaba.uml.behavior.UMLLink;
import de.uni_paderborn.fujaba.uml.behavior.UMLObject;
import de.upb.tools.fca.FEmptyListIterator;
import de.upb.tools.fca.FLinkedList; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDM; // requires Fujaba5/libs/RuntimeTools.jar in classpath
import de.upb.tools.sdm.JavaSDMException;


public class ExecutionPlanEngine extends TokenTreeMutatorEngine
{


   /**
    * <pre>
    *           0..1     costStrategies     0..n
    * ExecutionPlanEngine ------------------------- CostStrategy
    *           engine               costStrategies
    * </pre>
    */
   public static final String PROPERTY_COST_STRATEGIES = "costStrategies";

   @Property( name = PROPERTY_COST_STRATEGIES, partner = CostStrategy.PROPERTY_ENGINE, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.AGGREGATION)
   private FLinkedList<CostStrategy> costStrategies;

   @Property( name = PROPERTY_COST_STRATEGIES )
   public List<? extends CostStrategy> getCostStrategies()
   {
      return ((this.costStrategies == null)
              ? Collections.EMPTY_LIST
              : Collections.unmodifiableList(this.costStrategies));
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean addToCostStrategies (CostStrategy value)
   {
      boolean changed = false;

      if (value != null && !this.hasInCostStrategies (value))
      {
         if (this.costStrategies == null)
         {
            this.costStrategies = new FLinkedList<CostStrategy> ();

         }
      
         changed = this.costStrategies.add (value);
         if (changed)
         {
            value.setEngine (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public ExecutionPlanEngine withCostStrategies (CostStrategy value)
   {
      addToCostStrategies (value);
      return this;
   }

   public ExecutionPlanEngine withoutCostStrategies (CostStrategy value)
   {
      removeFromCostStrategies (value);
      return this;
   }


   public boolean removeFromCostStrategies (CostStrategy value)
   {
      boolean changed = false;

      if ((this.costStrategies != null) && (value != null))
      {
      
         changed = this.costStrategies.remove (value);
         if (changed)
         {
            value.setEngine (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public void removeAllFromCostStrategies (){
   
      CostStrategy tmpValue;
      Iterator<? extends CostStrategy> iter = this.iteratorOfCostStrategies ();
      while (iter.hasNext ())
      {
         tmpValue = (CostStrategy) iter.next ();
         this.removeFromCostStrategies (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean hasInCostStrategies (CostStrategy value)
   {
      return ((this.costStrategies != null) &&
              (value != null) &&
              this.costStrategies.contains (value));
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public ListIterator<? extends CostStrategy> iteratorOfCostStrategies ()
   {
      return ((this.costStrategies == null)
              ? FEmptyListIterator.<CostStrategy>get ()
              : this.costStrategies.listIterator());
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public int sizeOfCostStrategies ()
   {
      return ((this.costStrategies == null)
              ? 0
              : this.costStrategies.size ());
   }
   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getFirstOfCostStrategies ()
   {
      if (costStrategies == null)
      {
         return null;
      }
      else
      {
         if (costStrategies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (CostStrategy) costStrategies.getFirst ();
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getLastOfCostStrategies ()
   {
      if (costStrategies == null)
      {
         return null;
      }
      else
      {
         if (costStrategies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (CostStrategy) costStrategies.getLast ();
      }
   }
   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getFromCostStrategies ( int index )
   {
      if (index >= 0 && index < sizeOfCostStrategies ())
      {
         return (CostStrategy) this.costStrategies.get (index);
      }
      else
      {
         throw new IllegalArgumentException ("getCostStrategiesAt(" + index + ")" );
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public int indexOfCostStrategies ( CostStrategy value )
   {
      return ((this.costStrategies == null)
              ? -1
              : this.costStrategies.indexOf (value));
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public int indexOfCostStrategies ( CostStrategy value, int index )
   {
      return ((this.costStrategies == null)
   	       ? -1
   	       : this.costStrategies.indexOf (value, index));
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public int lastIndexOfCostStrategies ( CostStrategy value )
   {
      return ((this.costStrategies == null)
               ? -1
               : this.costStrategies.lastIndexOf (value));
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public int lastIndexOfCostStrategies ( CostStrategy value, int index )
   {
      return ((this.costStrategies == null)
               ? -1
               : this.costStrategies.lastIndexOf (value, index));
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean isBeforeOfCostStrategies ( CostStrategy leftObject, CostStrategy rightObject)
   {
      if (costStrategies == null)
      {
         return false;
      }
      else
      {
         return costStrategies.isBefore (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean isAfterOfCostStrategies ( CostStrategy leftObject, CostStrategy rightObject)
   {
      if (costStrategies == null)
      {
         return false;
      }
      else
      {
         return costStrategies.isAfter (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getNextOfCostStrategies ( CostStrategy object )
   {
      if (costStrategies == null)
      {
         return null;
      }
      else
      {
         return (CostStrategy) costStrategies.getNextOf (object);
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getNextOfCostStrategies ( CostStrategy object, int index)
   {
      if (costStrategies == null)
      {
         return null;
      }
      else
      {
         return (CostStrategy) costStrategies.getNextOf (object, index);
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getPreviousOfCostStrategies ( CostStrategy object)
   {
      if (costStrategies == null)
      {
         return null;
      }
      else
      {
         return (CostStrategy) costStrategies.getPreviousOf (object);
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public CostStrategy getPreviousOfCostStrategies ( CostStrategy object, int index )
   {
      if (costStrategies == null)
      {
         return null;
      }
      else
      {
         return (CostStrategy) costStrategies.getPreviousOf (object, index);
      }
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean addAfterOfCostStrategies ( CostStrategy refObject, CostStrategy value)
   {
      boolean changed = false;
      if (costStrategies != null)
      {
         int index = costStrategies.indexOf (refObject);
         changed = addToCostStrategies (index+1, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean addBeforeOfCostStrategies ( CostStrategy refObject, CostStrategy value)
   {
      boolean changed = false;
      if (costStrategies != null)
      {
         int index = costStrategies.indexOf (refObject);
         changed = addToCostStrategies (index, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean addToCostStrategies (int index, CostStrategy value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.costStrategies == null)
         {
            this.costStrategies = new FLinkedList<CostStrategy> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfCostStrategies (value);
         if (oldIndex != index)
         {
            try
            {
            
               if (oldIndex > -1)
               {
                  costStrategies.remove (oldIndex);
               }
               costStrategies.add (index, value);
               if (oldIndex < 0)
               {
                  value.setEngine (this);
               }
               changed = true;
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean setInCostStrategies (int index, CostStrategy value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.costStrategies == null)
         {
            this.costStrategies = new FLinkedList<CostStrategy> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfCostStrategies (value);
         if (oldIndex != index)
         {
            try
            {
            
               CostStrategy oldValue = (CostStrategy)this.costStrategies.set (index, value);
               if (oldIndex > -1)
               {
                  this.costStrategies.remove (oldIndex);
               }
               if (oldValue != value)
               {
                  if (oldValue != null)
                  {
                     oldValue.setEngine (null);
                  }
                  if (oldIndex < 0)
                  {
                     value.setEngine (this);
                  }
                  changed = true;
               }
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean removeFromCostStrategies (int index)
   {
      boolean changed = false;

      if (this.costStrategies != null && (index >= 0 && index < this.costStrategies.size ()))
      {
      
         CostStrategy tmpValue = (CostStrategy) this.costStrategies.remove (index);
         if (tmpValue != null)
         {
            tmpValue.setEngine (null);
            changed = true;
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public boolean removeFromCostStrategies (int index, CostStrategy value)
   {
      boolean changed = false;

      if ((this.costStrategies != null) && (value != null) && 
          (index >= 0 && index < this.costStrategies.size ()))
      {
         CostStrategy oldValue = (CostStrategy) this.costStrategies.get (index);
         if (oldValue == value)
         {
         
            changed = this.removeFromCostStrategies (index);
         
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public ListIterator<? extends CostStrategy> iteratorOfCostStrategies ( CostStrategy  lowerBound )
   {
      ListIterator<CostStrategy> result = FEmptyListIterator.<CostStrategy>get ();

      if (costStrategies != null && lowerBound != null)
      {
         int index = costStrategies.indexOf (lowerBound) + 1;
         result = costStrategies.listIterator (index);
      }
      else if (costStrategies != null && lowerBound == null)
      {
         result = costStrategies.listIterator (0);
      }

      return result;
   }

   @Property( name = PROPERTY_COST_STRATEGIES )
   public ListIterator<? extends CostStrategy> iteratorOfCostStrategies (int index)
   {
      return ((this.costStrategies == null)
              ? FEmptyListIterator.<CostStrategy>get ()
              : this.costStrategies.listIterator (Math.max(0,Math.min(index,this.costStrategies.size ()))));
   }

   public double getCost (Token operation )
   {
      boolean fujaba__Success = false;
      Iterator fujaba__IterThisToCostStrategy = null;
      CostStrategy costStrategy = null;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // iterate to-many link costStrategies from this to costStrategy
         fujaba__Success = false;
         fujaba__IterThisToCostStrategy = this.iteratorOfCostStrategies ();

         while ( !(fujaba__Success) && fujaba__IterThisToCostStrategy.hasNext () )
         {
            try
            {
               costStrategy = (CostStrategy) fujaba__IterThisToCostStrategy.next ();

               // check object costStrategy is really bound
               JavaSDM.ensure ( costStrategy != null );
               // constraint costStrategy.isResponsible (operation)
               JavaSDM.ensure ( costStrategy.isResponsible (operation) );

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         return 0;

      }
      return costStrategy.getCost (operation);
   }

   public Set getNestedDependencies (ExecuteStoryPatternOperation plan , Token op )
   {
      boolean fujaba__Success = false;
      HashSet deps = null;
      Iterator fujaba__IterThisToOpDep = null;
      OperationDependencies opDep = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // create object deps
         deps = new HashSet ( );

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // iterate to-many link nestingDependencies from this to opDep
         fujaba__Success = false;
         fujaba__IterThisToOpDep = this.iteratorOfNestingDependencies ();

         while ( fujaba__IterThisToOpDep.hasNext () )
         {
            try
            {
               opDep = (OperationDependencies) fujaba__IterThisToOpDep.next ();

               // check object opDep is really bound
               JavaSDM.ensure ( opDep != null );
               // collabStat call
               opDep.getDependencies (plan, op, deps);

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return deps;
   }

   public double getPathCost (Token from , Token to )
   {
      boolean fujaba__Success = false;
      Token tmpTo = null;
      double totalCost = 0.0;
      boolean hasFrom = false;
      double cost = 0.0;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         tmpTo = to;

         // collabStat call
         totalCost = 0;
         // collabStat call
         hasFrom = (from != null);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      while( true )
      {
         // story pattern Successor of successor
         try 
         {
            fujaba__Success = false; 

            // check object tmpTo is really bound
            JavaSDM.ensure ( tmpTo != null );
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }



      	// loop termination check 
      	if ( !( fujaba__Success ) )
      	{
      		break;
      	}
	
         // story pattern successor
         try 
         {
            fujaba__Success = false; 

            // collabStat call
            cost = getCost (tmpTo);
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }

         if ( cost <= 0 )
         {
            return 0;

         }
         // story pattern successor
         try 
         {
            fujaba__Success = false; 

            // collabStat call
            totalCost = totalCost + cost;
            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }

         if ( hasFrom )
         {
            // story pattern successor
            try 
            {
               fujaba__Success = false; 

               // check object from is really bound
               JavaSDM.ensure ( from != null );
               // check object tmpTo is really bound
               JavaSDM.ensure ( tmpTo != null );
               // check isomorphic binding between objects tmpTo and from
               JavaSDM.ensure ( !tmpTo.equals (from) );

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }

            if ( !( fujaba__Success ) )
            {
               return totalCost;

            }

         }
         // story pattern successor
         try 
         {
            fujaba__Success = false; 

            tmpTo = tmpTo.getParent ();

            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      if ( hasFrom )
      {
         return totalCost;

      }
      return 0;
   }

   public double getPayload (UMLLink link , UMLObject target )
   {
      boolean fujaba__Success = false;
      UMLObject source = null;
      Iterator fujaba__IterThisToPayloadStrat = null;
      PayloadStrategy payloadStrat = null;
      double payload = 0.0;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object link is really bound
         JavaSDM.ensure ( link != null );
         // check object target is really bound
         JavaSDM.ensure ( target != null );
         // check link target from link to target
         JavaSDM.ensure (target.equals (link.getTarget ()));

         // search to-one link source from link to source
         source = link.getSource ();

         // check object source is really bound
         JavaSDM.ensure ( source != null );

         // check isomorphic binding between objects target and source
         JavaSDM.ensure ( !target.equals (source) );


         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         // story pattern Successor of successor
         try 
         {
            fujaba__Success = false; 

            // check object link is really bound
            JavaSDM.ensure ( link != null );
            // check object target is really bound
            JavaSDM.ensure ( target != null );
            // check link source from link to target
            JavaSDM.ensure (target.equals (link.getSource ()));

            // search to-one link target from link to source
            source = link.getTarget ();

            // check object source is really bound
            JavaSDM.ensure ( source != null );

            // check isomorphic binding between objects target and source
            JavaSDM.ensure ( !target.equals (source) );


            fujaba__Success = true;
         }
         catch ( JavaSDMException fujaba__InternalException )
         {
            fujaba__Success = false;
         }


      }
      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // iterate to-many link payloadStrategies from this to payloadStrat
         fujaba__Success = false;
         fujaba__IterThisToPayloadStrat = this.iteratorOfPayloadStrategies ();

         while ( !(fujaba__Success) && fujaba__IterThisToPayloadStrat.hasNext () )
         {
            try
            {
               payloadStrat = (PayloadStrategy) fujaba__IterThisToPayloadStrat.next ();

               // check object payloadStrat is really bound
               JavaSDM.ensure ( payloadStrat != null );
               // constraint payloadStrat.isResponsible (link, target)
               JavaSDM.ensure ( payloadStrat.isResponsible (link, target) );

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         // collabStat call
         payload = payloadStrat.getPayload (link, source, target);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return payload;

      }
      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // collabStat call
         warning("Payload strategy missing", link);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return -1;
   }

   public Set getSequentialDependencies (ExecuteStoryPatternOperation plan , Token op )
   {
      boolean fujaba__Success = false;
      HashSet deps = null;
      Iterator fujaba__IterThisToOpDep = null;
      OperationDependencies opDep = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // create object deps
         deps = new HashSet ( );

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // iterate to-many link sequentialDependencies from this to opDep
         fujaba__Success = false;
         fujaba__IterThisToOpDep = this.iteratorOfSequentialDependencies ();

         while ( fujaba__IterThisToOpDep.hasNext () )
         {
            try
            {
               opDep = (OperationDependencies) fujaba__IterThisToOpDep.next ();

               // check object opDep is really bound
               JavaSDM.ensure ( opDep != null );
               // collabStat call
               opDep.getDependencies (plan, op, deps);

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return deps;
   }

   public double getSubtreeCost (Token root )
   {

      return getSubtreeCost (root, null);
   }

   public double getSubtreeCost (Token root , Token to )
   {
      boolean fujaba__Success = false;
      double cost = 0.0;
      Iterator fujaba__IterRootToChild = null;
      Token child = null;

      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object root is really bound
         JavaSDM.ensure ( root != null );
         // constraint to == null || root.isAncestorOf (to)
         JavaSDM.ensure ( to == null || root.isAncestorOf (to) );
         // collabStat call
         cost = getCost (root);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( !( fujaba__Success ) )
      {
         throw new IllegalArgumentException (to+" not a child of "+root);

      }
      if ( to == root )
      {
         return cost;

      }
      // story pattern successor
      try 
      {
         fujaba__Success = false; 

         // check object root is really bound
         JavaSDM.ensure ( root != null );
         // iterate to-many link children from root to child
         fujaba__Success = false;
         fujaba__IterRootToChild = root.iteratorOfChildren ();

         while ( fujaba__IterRootToChild.hasNext () )
         {
            try
            {
               child = (Token) fujaba__IterRootToChild.next ();

               // check object child is really bound
               JavaSDM.ensure ( child != null );
               // check isomorphic binding between objects root and child
               JavaSDM.ensure ( !root.equals (child) );

               // story pattern successor
               try 
               {
                  fujaba__Success = false; 

                  // collabStat call
                  cost = cost + getSubtreeCost (child, to);
                  fujaba__Success = true;
               }
               catch ( JavaSDMException fujaba__InternalException )
               {
                  fujaba__Success = false;
               }

               if ( child == to )
               {
                  return cost;

               }

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return cost;
   }

   public boolean mutateTree (Token token )
   {
      boolean fujaba__Success = false;
      Object _TmpObject = null;
      ExecuteStoryPatternOperation story = null;

      // story pattern 
      try 
      {
         fujaba__Success = false; 

         _TmpObject = token;

         // ensure correct type and really bound of object story
         JavaSDM.ensure ( _TmpObject instanceof ExecuteStoryPatternOperation );
         story = (ExecuteStoryPatternOperation) _TmpObject;

         // collabStat call
         this.plan (story);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      if ( fujaba__Success )
      {
         return true;

      }
      return true;
   }

   /**
    * <pre>
    *           0..1     mutators     0..n
    * ExecutionPlanEngine ------------------------- PlanMutator
    *           engine               mutators
    * </pre>
    */
   public static final String PROPERTY_MUTATORS = "mutators";

   @Property( name = PROPERTY_MUTATORS, partner = PlanMutator.PROPERTY_ENGINE, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.AGGREGATION)
   private FLinkedList<PlanMutator> mutators;

   @Property( name = PROPERTY_MUTATORS )
   public List<? extends PlanMutator> getMutators()
   {
      return ((this.mutators == null)
              ? Collections.EMPTY_LIST
              : Collections.unmodifiableList(this.mutators));
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean addToMutators (PlanMutator value)
   {
      boolean changed = false;

      if (value != null && !this.hasInMutators (value))
      {
         if (this.mutators == null)
         {
            this.mutators = new FLinkedList<PlanMutator> ();

         }
      
         changed = this.mutators.add (value);
         if (changed)
         {
            value.setEngine (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public ExecutionPlanEngine withMutators (PlanMutator value)
   {
      addToMutators (value);
      return this;
   }

   public ExecutionPlanEngine withoutMutators (PlanMutator value)
   {
      removeFromMutators (value);
      return this;
   }


   public boolean removeFromMutators (PlanMutator value)
   {
      boolean changed = false;

      if ((this.mutators != null) && (value != null))
      {
      
         changed = this.mutators.remove (value);
         if (changed)
         {
            value.setEngine (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public void removeAllFromMutators (){
   
      PlanMutator tmpValue;
      Iterator<? extends PlanMutator> iter = this.iteratorOfMutators ();
      while (iter.hasNext ())
      {
         tmpValue = (PlanMutator) iter.next ();
         this.removeFromMutators (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean hasInMutators (PlanMutator value)
   {
      return ((this.mutators != null) &&
              (value != null) &&
              this.mutators.contains (value));
   }

   @Property( name = PROPERTY_MUTATORS )
   public ListIterator<? extends PlanMutator> iteratorOfMutators ()
   {
      return ((this.mutators == null)
              ? FEmptyListIterator.<PlanMutator>get ()
              : this.mutators.listIterator());
   }

   @Property( name = PROPERTY_MUTATORS )
   public int sizeOfMutators ()
   {
      return ((this.mutators == null)
              ? 0
              : this.mutators.size ());
   }
   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getFirstOfMutators ()
   {
      if (mutators == null)
      {
         return null;
      }
      else
      {
         if (mutators.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (PlanMutator) mutators.getFirst ();
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getLastOfMutators ()
   {
      if (mutators == null)
      {
         return null;
      }
      else
      {
         if (mutators.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (PlanMutator) mutators.getLast ();
      }
   }
   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getFromMutators ( int index )
   {
      if (index >= 0 && index < sizeOfMutators ())
      {
         return (PlanMutator) this.mutators.get (index);
      }
      else
      {
         throw new IllegalArgumentException ("getMutatorsAt(" + index + ")" );
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public int indexOfMutators ( PlanMutator value )
   {
      return ((this.mutators == null)
              ? -1
              : this.mutators.indexOf (value));
   }

   @Property( name = PROPERTY_MUTATORS )
   public int indexOfMutators ( PlanMutator value, int index )
   {
      return ((this.mutators == null)
   	       ? -1
   	       : this.mutators.indexOf (value, index));
   }

   @Property( name = PROPERTY_MUTATORS )
   public int lastIndexOfMutators ( PlanMutator value )
   {
      return ((this.mutators == null)
               ? -1
               : this.mutators.lastIndexOf (value));
   }

   @Property( name = PROPERTY_MUTATORS )
   public int lastIndexOfMutators ( PlanMutator value, int index )
   {
      return ((this.mutators == null)
               ? -1
               : this.mutators.lastIndexOf (value, index));
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean isBeforeOfMutators ( PlanMutator leftObject, PlanMutator rightObject)
   {
      if (mutators == null)
      {
         return false;
      }
      else
      {
         return mutators.isBefore (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean isAfterOfMutators ( PlanMutator leftObject, PlanMutator rightObject)
   {
      if (mutators == null)
      {
         return false;
      }
      else
      {
         return mutators.isAfter (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getNextOfMutators ( PlanMutator object )
   {
      if (mutators == null)
      {
         return null;
      }
      else
      {
         return (PlanMutator) mutators.getNextOf (object);
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getNextOfMutators ( PlanMutator object, int index)
   {
      if (mutators == null)
      {
         return null;
      }
      else
      {
         return (PlanMutator) mutators.getNextOf (object, index);
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getPreviousOfMutators ( PlanMutator object)
   {
      if (mutators == null)
      {
         return null;
      }
      else
      {
         return (PlanMutator) mutators.getPreviousOf (object);
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public PlanMutator getPreviousOfMutators ( PlanMutator object, int index )
   {
      if (mutators == null)
      {
         return null;
      }
      else
      {
         return (PlanMutator) mutators.getPreviousOf (object, index);
      }
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean addAfterOfMutators ( PlanMutator refObject, PlanMutator value)
   {
      boolean changed = false;
      if (mutators != null)
      {
         int index = mutators.indexOf (refObject);
         changed = addToMutators (index+1, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean addBeforeOfMutators ( PlanMutator refObject, PlanMutator value)
   {
      boolean changed = false;
      if (mutators != null)
      {
         int index = mutators.indexOf (refObject);
         changed = addToMutators (index, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean addToMutators (int index, PlanMutator value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.mutators == null)
         {
            this.mutators = new FLinkedList<PlanMutator> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfMutators (value);
         if (oldIndex != index)
         {
            try
            {
            
               if (oldIndex > -1)
               {
                  mutators.remove (oldIndex);
               }
               mutators.add (index, value);
               if (oldIndex < 0)
               {
                  value.setEngine (this);
               }
               changed = true;
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean setInMutators (int index, PlanMutator value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.mutators == null)
         {
            this.mutators = new FLinkedList<PlanMutator> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfMutators (value);
         if (oldIndex != index)
         {
            try
            {
            
               PlanMutator oldValue = (PlanMutator)this.mutators.set (index, value);
               if (oldIndex > -1)
               {
                  this.mutators.remove (oldIndex);
               }
               if (oldValue != value)
               {
                  if (oldValue != null)
                  {
                     oldValue.setEngine (null);
                  }
                  if (oldIndex < 0)
                  {
                     value.setEngine (this);
                  }
                  changed = true;
               }
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean removeFromMutators (int index)
   {
      boolean changed = false;

      if (this.mutators != null && (index >= 0 && index < this.mutators.size ()))
      {
      
         PlanMutator tmpValue = (PlanMutator) this.mutators.remove (index);
         if (tmpValue != null)
         {
            tmpValue.setEngine (null);
            changed = true;
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public boolean removeFromMutators (int index, PlanMutator value)
   {
      boolean changed = false;

      if ((this.mutators != null) && (value != null) && 
          (index >= 0 && index < this.mutators.size ()))
      {
         PlanMutator oldValue = (PlanMutator) this.mutators.get (index);
         if (oldValue == value)
         {
         
            changed = this.removeFromMutators (index);
         
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_MUTATORS )
   public ListIterator<? extends PlanMutator> iteratorOfMutators ( PlanMutator  lowerBound )
   {
      ListIterator<PlanMutator> result = FEmptyListIterator.<PlanMutator>get ();

      if (mutators != null && lowerBound != null)
      {
         int index = mutators.indexOf (lowerBound) + 1;
         result = mutators.listIterator (index);
      }
      else if (mutators != null && lowerBound == null)
      {
         result = mutators.listIterator (0);
      }

      return result;
   }

   @Property( name = PROPERTY_MUTATORS )
   public ListIterator<? extends PlanMutator> iteratorOfMutators (int index)
   {
      return ((this.mutators == null)
              ? FEmptyListIterator.<PlanMutator>get ()
              : this.mutators.listIterator (Math.max(0,Math.min(index,this.mutators.size ()))));
   }

   /**
    * <pre>
    *           0..1     nestingDependencies     0..n
    * ExecutionPlanEngine ------------------------- OperationDependencies
    *           engine               nestingDependencies
    * </pre>
    */
   public static final String PROPERTY_NESTING_DEPENDENCIES = "nestingDependencies";

   @Property( name = PROPERTY_NESTING_DEPENDENCIES, partner = OperationDependencies.PROPERTY_ENGINE, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.AGGREGATION)
   private FLinkedList<OperationDependencies> nestingDependencies;

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public List<? extends OperationDependencies> getNestingDependencies()
   {
      return ((this.nestingDependencies == null)
              ? Collections.EMPTY_LIST
              : Collections.unmodifiableList(this.nestingDependencies));
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean addToNestingDependencies (OperationDependencies value)
   {
      boolean changed = false;

      if (value != null && !this.hasInNestingDependencies (value))
      {
         if (this.nestingDependencies == null)
         {
            this.nestingDependencies = new FLinkedList<OperationDependencies> ();

         }
      
         changed = this.nestingDependencies.add (value);
         if (changed)
         {
            value.setEngine (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public ExecutionPlanEngine withNestingDependencies (OperationDependencies value)
   {
      addToNestingDependencies (value);
      return this;
   }

   public ExecutionPlanEngine withoutNestingDependencies (OperationDependencies value)
   {
      removeFromNestingDependencies (value);
      return this;
   }


   public boolean removeFromNestingDependencies (OperationDependencies value)
   {
      boolean changed = false;

      if ((this.nestingDependencies != null) && (value != null))
      {
      
         changed = this.nestingDependencies.remove (value);
         if (changed)
         {
            value.setEngine (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public void removeAllFromNestingDependencies (){
   
      OperationDependencies tmpValue;
      Iterator<? extends OperationDependencies> iter = this.iteratorOfNestingDependencies ();
      while (iter.hasNext ())
      {
         tmpValue = (OperationDependencies) iter.next ();
         this.removeFromNestingDependencies (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean hasInNestingDependencies (OperationDependencies value)
   {
      return ((this.nestingDependencies != null) &&
              (value != null) &&
              this.nestingDependencies.contains (value));
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public ListIterator<? extends OperationDependencies> iteratorOfNestingDependencies ()
   {
      return ((this.nestingDependencies == null)
              ? FEmptyListIterator.<OperationDependencies>get ()
              : this.nestingDependencies.listIterator());
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public int sizeOfNestingDependencies ()
   {
      return ((this.nestingDependencies == null)
              ? 0
              : this.nestingDependencies.size ());
   }
   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getFirstOfNestingDependencies ()
   {
      if (nestingDependencies == null)
      {
         return null;
      }
      else
      {
         if (nestingDependencies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (OperationDependencies) nestingDependencies.getFirst ();
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getLastOfNestingDependencies ()
   {
      if (nestingDependencies == null)
      {
         return null;
      }
      else
      {
         if (nestingDependencies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (OperationDependencies) nestingDependencies.getLast ();
      }
   }
   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getFromNestingDependencies ( int index )
   {
      if (index >= 0 && index < sizeOfNestingDependencies ())
      {
         return (OperationDependencies) this.nestingDependencies.get (index);
      }
      else
      {
         throw new IllegalArgumentException ("getNestingDependenciesAt(" + index + ")" );
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public int indexOfNestingDependencies ( OperationDependencies value )
   {
      return ((this.nestingDependencies == null)
              ? -1
              : this.nestingDependencies.indexOf (value));
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public int indexOfNestingDependencies ( OperationDependencies value, int index )
   {
      return ((this.nestingDependencies == null)
   	       ? -1
   	       : this.nestingDependencies.indexOf (value, index));
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public int lastIndexOfNestingDependencies ( OperationDependencies value )
   {
      return ((this.nestingDependencies == null)
               ? -1
               : this.nestingDependencies.lastIndexOf (value));
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public int lastIndexOfNestingDependencies ( OperationDependencies value, int index )
   {
      return ((this.nestingDependencies == null)
               ? -1
               : this.nestingDependencies.lastIndexOf (value, index));
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean isBeforeOfNestingDependencies ( OperationDependencies leftObject, OperationDependencies rightObject)
   {
      if (nestingDependencies == null)
      {
         return false;
      }
      else
      {
         return nestingDependencies.isBefore (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean isAfterOfNestingDependencies ( OperationDependencies leftObject, OperationDependencies rightObject)
   {
      if (nestingDependencies == null)
      {
         return false;
      }
      else
      {
         return nestingDependencies.isAfter (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getNextOfNestingDependencies ( OperationDependencies object )
   {
      if (nestingDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) nestingDependencies.getNextOf (object);
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getNextOfNestingDependencies ( OperationDependencies object, int index)
   {
      if (nestingDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) nestingDependencies.getNextOf (object, index);
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getPreviousOfNestingDependencies ( OperationDependencies object)
   {
      if (nestingDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) nestingDependencies.getPreviousOf (object);
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public OperationDependencies getPreviousOfNestingDependencies ( OperationDependencies object, int index )
   {
      if (nestingDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) nestingDependencies.getPreviousOf (object, index);
      }
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean addAfterOfNestingDependencies ( OperationDependencies refObject, OperationDependencies value)
   {
      boolean changed = false;
      if (nestingDependencies != null)
      {
         int index = nestingDependencies.indexOf (refObject);
         changed = addToNestingDependencies (index+1, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean addBeforeOfNestingDependencies ( OperationDependencies refObject, OperationDependencies value)
   {
      boolean changed = false;
      if (nestingDependencies != null)
      {
         int index = nestingDependencies.indexOf (refObject);
         changed = addToNestingDependencies (index, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean addToNestingDependencies (int index, OperationDependencies value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.nestingDependencies == null)
         {
            this.nestingDependencies = new FLinkedList<OperationDependencies> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfNestingDependencies (value);
         if (oldIndex != index)
         {
            try
            {
            
               if (oldIndex > -1)
               {
                  nestingDependencies.remove (oldIndex);
               }
               nestingDependencies.add (index, value);
               if (oldIndex < 0)
               {
                  value.setEngine (this);
               }
               changed = true;
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean setInNestingDependencies (int index, OperationDependencies value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.nestingDependencies == null)
         {
            this.nestingDependencies = new FLinkedList<OperationDependencies> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfNestingDependencies (value);
         if (oldIndex != index)
         {
            try
            {
            
               OperationDependencies oldValue = (OperationDependencies)this.nestingDependencies.set (index, value);
               if (oldIndex > -1)
               {
                  this.nestingDependencies.remove (oldIndex);
               }
               if (oldValue != value)
               {
                  if (oldValue != null)
                  {
                     oldValue.setEngine (null);
                  }
                  if (oldIndex < 0)
                  {
                     value.setEngine (this);
                  }
                  changed = true;
               }
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean removeFromNestingDependencies (int index)
   {
      boolean changed = false;

      if (this.nestingDependencies != null && (index >= 0 && index < this.nestingDependencies.size ()))
      {
      
         OperationDependencies tmpValue = (OperationDependencies) this.nestingDependencies.remove (index);
         if (tmpValue != null)
         {
            tmpValue.setEngine (null);
            changed = true;
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public boolean removeFromNestingDependencies (int index, OperationDependencies value)
   {
      boolean changed = false;

      if ((this.nestingDependencies != null) && (value != null) && 
          (index >= 0 && index < this.nestingDependencies.size ()))
      {
         OperationDependencies oldValue = (OperationDependencies) this.nestingDependencies.get (index);
         if (oldValue == value)
         {
         
            changed = this.removeFromNestingDependencies (index);
         
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public ListIterator<? extends OperationDependencies> iteratorOfNestingDependencies ( OperationDependencies  lowerBound )
   {
      ListIterator<OperationDependencies> result = FEmptyListIterator.<OperationDependencies>get ();

      if (nestingDependencies != null && lowerBound != null)
      {
         int index = nestingDependencies.indexOf (lowerBound) + 1;
         result = nestingDependencies.listIterator (index);
      }
      else if (nestingDependencies != null && lowerBound == null)
      {
         result = nestingDependencies.listIterator (0);
      }

      return result;
   }

   @Property( name = PROPERTY_NESTING_DEPENDENCIES )
   public ListIterator<? extends OperationDependencies> iteratorOfNestingDependencies (int index)
   {
      return ((this.nestingDependencies == null)
              ? FEmptyListIterator.<OperationDependencies>get ()
              : this.nestingDependencies.listIterator (Math.max(0,Math.min(index,this.nestingDependencies.size ()))));
   }

   /**
    * <pre>
    *           0..1     payloadStrategies     0..n
    * ExecutionPlanEngine ------------------------- PayloadStrategy
    *           engine               payloadStrategies
    * </pre>
    */
   public static final String PROPERTY_PAYLOAD_STRATEGIES = "payloadStrategies";

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES, partner = PayloadStrategy.PROPERTY_ENGINE, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.AGGREGATION)
   private FLinkedList<PayloadStrategy> payloadStrategies;

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public List<? extends PayloadStrategy> getPayloadStrategies()
   {
      return ((this.payloadStrategies == null)
              ? Collections.EMPTY_LIST
              : Collections.unmodifiableList(this.payloadStrategies));
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean addToPayloadStrategies (PayloadStrategy value)
   {
      boolean changed = false;

      if (value != null && !this.hasInPayloadStrategies (value))
      {
         if (this.payloadStrategies == null)
         {
            this.payloadStrategies = new FLinkedList<PayloadStrategy> ();

         }
      
         changed = this.payloadStrategies.add (value);
         if (changed)
         {
            value.setEngine (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public ExecutionPlanEngine withPayloadStrategies (PayloadStrategy value)
   {
      addToPayloadStrategies (value);
      return this;
   }

   public ExecutionPlanEngine withoutPayloadStrategies (PayloadStrategy value)
   {
      removeFromPayloadStrategies (value);
      return this;
   }


   public boolean removeFromPayloadStrategies (PayloadStrategy value)
   {
      boolean changed = false;

      if ((this.payloadStrategies != null) && (value != null))
      {
      
         changed = this.payloadStrategies.remove (value);
         if (changed)
         {
            value.setEngine (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public void removeAllFromPayloadStrategies (){
   
      PayloadStrategy tmpValue;
      Iterator<? extends PayloadStrategy> iter = this.iteratorOfPayloadStrategies ();
      while (iter.hasNext ())
      {
         tmpValue = (PayloadStrategy) iter.next ();
         this.removeFromPayloadStrategies (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean hasInPayloadStrategies (PayloadStrategy value)
   {
      return ((this.payloadStrategies != null) &&
              (value != null) &&
              this.payloadStrategies.contains (value));
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public ListIterator<? extends PayloadStrategy> iteratorOfPayloadStrategies ()
   {
      return ((this.payloadStrategies == null)
              ? FEmptyListIterator.<PayloadStrategy>get ()
              : this.payloadStrategies.listIterator());
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public int sizeOfPayloadStrategies ()
   {
      return ((this.payloadStrategies == null)
              ? 0
              : this.payloadStrategies.size ());
   }
   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getFirstOfPayloadStrategies ()
   {
      if (payloadStrategies == null)
      {
         return null;
      }
      else
      {
         if (payloadStrategies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (PayloadStrategy) payloadStrategies.getFirst ();
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getLastOfPayloadStrategies ()
   {
      if (payloadStrategies == null)
      {
         return null;
      }
      else
      {
         if (payloadStrategies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (PayloadStrategy) payloadStrategies.getLast ();
      }
   }
   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getFromPayloadStrategies ( int index )
   {
      if (index >= 0 && index < sizeOfPayloadStrategies ())
      {
         return (PayloadStrategy) this.payloadStrategies.get (index);
      }
      else
      {
         throw new IllegalArgumentException ("getPayloadStrategiesAt(" + index + ")" );
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public int indexOfPayloadStrategies ( PayloadStrategy value )
   {
      return ((this.payloadStrategies == null)
              ? -1
              : this.payloadStrategies.indexOf (value));
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public int indexOfPayloadStrategies ( PayloadStrategy value, int index )
   {
      return ((this.payloadStrategies == null)
   	       ? -1
   	       : this.payloadStrategies.indexOf (value, index));
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public int lastIndexOfPayloadStrategies ( PayloadStrategy value )
   {
      return ((this.payloadStrategies == null)
               ? -1
               : this.payloadStrategies.lastIndexOf (value));
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public int lastIndexOfPayloadStrategies ( PayloadStrategy value, int index )
   {
      return ((this.payloadStrategies == null)
               ? -1
               : this.payloadStrategies.lastIndexOf (value, index));
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean isBeforeOfPayloadStrategies ( PayloadStrategy leftObject, PayloadStrategy rightObject)
   {
      if (payloadStrategies == null)
      {
         return false;
      }
      else
      {
         return payloadStrategies.isBefore (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean isAfterOfPayloadStrategies ( PayloadStrategy leftObject, PayloadStrategy rightObject)
   {
      if (payloadStrategies == null)
      {
         return false;
      }
      else
      {
         return payloadStrategies.isAfter (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getNextOfPayloadStrategies ( PayloadStrategy object )
   {
      if (payloadStrategies == null)
      {
         return null;
      }
      else
      {
         return (PayloadStrategy) payloadStrategies.getNextOf (object);
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getNextOfPayloadStrategies ( PayloadStrategy object, int index)
   {
      if (payloadStrategies == null)
      {
         return null;
      }
      else
      {
         return (PayloadStrategy) payloadStrategies.getNextOf (object, index);
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getPreviousOfPayloadStrategies ( PayloadStrategy object)
   {
      if (payloadStrategies == null)
      {
         return null;
      }
      else
      {
         return (PayloadStrategy) payloadStrategies.getPreviousOf (object);
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public PayloadStrategy getPreviousOfPayloadStrategies ( PayloadStrategy object, int index )
   {
      if (payloadStrategies == null)
      {
         return null;
      }
      else
      {
         return (PayloadStrategy) payloadStrategies.getPreviousOf (object, index);
      }
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean addAfterOfPayloadStrategies ( PayloadStrategy refObject, PayloadStrategy value)
   {
      boolean changed = false;
      if (payloadStrategies != null)
      {
         int index = payloadStrategies.indexOf (refObject);
         changed = addToPayloadStrategies (index+1, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean addBeforeOfPayloadStrategies ( PayloadStrategy refObject, PayloadStrategy value)
   {
      boolean changed = false;
      if (payloadStrategies != null)
      {
         int index = payloadStrategies.indexOf (refObject);
         changed = addToPayloadStrategies (index, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean addToPayloadStrategies (int index, PayloadStrategy value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.payloadStrategies == null)
         {
            this.payloadStrategies = new FLinkedList<PayloadStrategy> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfPayloadStrategies (value);
         if (oldIndex != index)
         {
            try
            {
            
               if (oldIndex > -1)
               {
                  payloadStrategies.remove (oldIndex);
               }
               payloadStrategies.add (index, value);
               if (oldIndex < 0)
               {
                  value.setEngine (this);
               }
               changed = true;
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean setInPayloadStrategies (int index, PayloadStrategy value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.payloadStrategies == null)
         {
            this.payloadStrategies = new FLinkedList<PayloadStrategy> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfPayloadStrategies (value);
         if (oldIndex != index)
         {
            try
            {
            
               PayloadStrategy oldValue = (PayloadStrategy)this.payloadStrategies.set (index, value);
               if (oldIndex > -1)
               {
                  this.payloadStrategies.remove (oldIndex);
               }
               if (oldValue != value)
               {
                  if (oldValue != null)
                  {
                     oldValue.setEngine (null);
                  }
                  if (oldIndex < 0)
                  {
                     value.setEngine (this);
                  }
                  changed = true;
               }
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean removeFromPayloadStrategies (int index)
   {
      boolean changed = false;

      if (this.payloadStrategies != null && (index >= 0 && index < this.payloadStrategies.size ()))
      {
      
         PayloadStrategy tmpValue = (PayloadStrategy) this.payloadStrategies.remove (index);
         if (tmpValue != null)
         {
            tmpValue.setEngine (null);
            changed = true;
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public boolean removeFromPayloadStrategies (int index, PayloadStrategy value)
   {
      boolean changed = false;

      if ((this.payloadStrategies != null) && (value != null) && 
          (index >= 0 && index < this.payloadStrategies.size ()))
      {
         PayloadStrategy oldValue = (PayloadStrategy) this.payloadStrategies.get (index);
         if (oldValue == value)
         {
         
            changed = this.removeFromPayloadStrategies (index);
         
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public ListIterator<? extends PayloadStrategy> iteratorOfPayloadStrategies ( PayloadStrategy  lowerBound )
   {
      ListIterator<PayloadStrategy> result = FEmptyListIterator.<PayloadStrategy>get ();

      if (payloadStrategies != null && lowerBound != null)
      {
         int index = payloadStrategies.indexOf (lowerBound) + 1;
         result = payloadStrategies.listIterator (index);
      }
      else if (payloadStrategies != null && lowerBound == null)
      {
         result = payloadStrategies.listIterator (0);
      }

      return result;
   }

   @Property( name = PROPERTY_PAYLOAD_STRATEGIES )
   public ListIterator<? extends PayloadStrategy> iteratorOfPayloadStrategies (int index)
   {
      return ((this.payloadStrategies == null)
              ? FEmptyListIterator.<PayloadStrategy>get ()
              : this.payloadStrategies.listIterator (Math.max(0,Math.min(index,this.payloadStrategies.size ()))));
   }

   public void plan (ExecuteStoryPatternOperation plan )
   {
      boolean fujaba__Success = false;
      Iterator fujaba__IterThisToMutator = null;
      PlanMutator mutator = null;

      // story pattern 
      try 
      {
         fujaba__Success = false; 

         // iterate to-many link mutators from this to mutator
         fujaba__Success = false;
         fujaba__IterThisToMutator = this.iteratorOfMutators ();

         while ( fujaba__IterThisToMutator.hasNext () )
         {
            try
            {
               mutator = (PlanMutator) fujaba__IterThisToMutator.next ();

               // check object mutator is really bound
               JavaSDM.ensure ( mutator != null );
               // collabStat call
               mutator.mutate (plan);

               fujaba__Success = true;
            }
            catch ( JavaSDMException fujaba__InternalException )
            {
               fujaba__Success = false;
            }
         }
         JavaSDM.ensure (fujaba__Success);
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

   }

   /**
    * <pre>
    *           0..1     sequentialDependencies     0..n
    * ExecutionPlanEngine ------------------------- OperationDependencies
    *           engine1               sequentialDependencies
    * </pre>
    */
   public static final String PROPERTY_SEQUENTIAL_DEPENDENCIES = "sequentialDependencies";

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES, partner = OperationDependencies.PROPERTY_ENGINE1, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.AGGREGATION)
   private FLinkedList<OperationDependencies> sequentialDependencies;

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public List<? extends OperationDependencies> getSequentialDependencies()
   {
      return ((this.sequentialDependencies == null)
              ? Collections.EMPTY_LIST
              : Collections.unmodifiableList(this.sequentialDependencies));
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean addToSequentialDependencies (OperationDependencies value)
   {
      boolean changed = false;

      if (value != null && !this.hasInSequentialDependencies (value))
      {
         if (this.sequentialDependencies == null)
         {
            this.sequentialDependencies = new FLinkedList<OperationDependencies> ();

         }
      
         changed = this.sequentialDependencies.add (value);
         if (changed)
         {
            value.setEngine1 (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public ExecutionPlanEngine withSequentialDependencies (OperationDependencies value)
   {
      addToSequentialDependencies (value);
      return this;
   }

   public ExecutionPlanEngine withoutSequentialDependencies (OperationDependencies value)
   {
      removeFromSequentialDependencies (value);
      return this;
   }


   public boolean removeFromSequentialDependencies (OperationDependencies value)
   {
      boolean changed = false;

      if ((this.sequentialDependencies != null) && (value != null))
      {
      
         changed = this.sequentialDependencies.remove (value);
         if (changed)
         {
            value.setEngine1 (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public void removeAllFromSequentialDependencies (){
   
      OperationDependencies tmpValue;
      Iterator<? extends OperationDependencies> iter = this.iteratorOfSequentialDependencies ();
      while (iter.hasNext ())
      {
         tmpValue = (OperationDependencies) iter.next ();
         this.removeFromSequentialDependencies (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean hasInSequentialDependencies (OperationDependencies value)
   {
      return ((this.sequentialDependencies != null) &&
              (value != null) &&
              this.sequentialDependencies.contains (value));
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public ListIterator<? extends OperationDependencies> iteratorOfSequentialDependencies ()
   {
      return ((this.sequentialDependencies == null)
              ? FEmptyListIterator.<OperationDependencies>get ()
              : this.sequentialDependencies.listIterator());
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public int sizeOfSequentialDependencies ()
   {
      return ((this.sequentialDependencies == null)
              ? 0
              : this.sequentialDependencies.size ());
   }
   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getFirstOfSequentialDependencies ()
   {
      if (sequentialDependencies == null)
      {
         return null;
      }
      else
      {
         if (sequentialDependencies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (OperationDependencies) sequentialDependencies.getFirst ();
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getLastOfSequentialDependencies ()
   {
      if (sequentialDependencies == null)
      {
         return null;
      }
      else
      {
         if (sequentialDependencies.size() == 0) 	 
         { 	 
            return null; 	 
         }
         return (OperationDependencies) sequentialDependencies.getLast ();
      }
   }
   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getFromSequentialDependencies ( int index )
   {
      if (index >= 0 && index < sizeOfSequentialDependencies ())
      {
         return (OperationDependencies) this.sequentialDependencies.get (index);
      }
      else
      {
         throw new IllegalArgumentException ("getSequentialDependenciesAt(" + index + ")" );
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public int indexOfSequentialDependencies ( OperationDependencies value )
   {
      return ((this.sequentialDependencies == null)
              ? -1
              : this.sequentialDependencies.indexOf (value));
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public int indexOfSequentialDependencies ( OperationDependencies value, int index )
   {
      return ((this.sequentialDependencies == null)
   	       ? -1
   	       : this.sequentialDependencies.indexOf (value, index));
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public int lastIndexOfSequentialDependencies ( OperationDependencies value )
   {
      return ((this.sequentialDependencies == null)
               ? -1
               : this.sequentialDependencies.lastIndexOf (value));
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public int lastIndexOfSequentialDependencies ( OperationDependencies value, int index )
   {
      return ((this.sequentialDependencies == null)
               ? -1
               : this.sequentialDependencies.lastIndexOf (value, index));
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean isBeforeOfSequentialDependencies ( OperationDependencies leftObject, OperationDependencies rightObject)
   {
      if (sequentialDependencies == null)
      {
         return false;
      }
      else
      {
         return sequentialDependencies.isBefore (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean isAfterOfSequentialDependencies ( OperationDependencies leftObject, OperationDependencies rightObject)
   {
      if (sequentialDependencies == null)
      {
         return false;
      }
      else
      {
         return sequentialDependencies.isAfter (leftObject, rightObject);
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getNextOfSequentialDependencies ( OperationDependencies object )
   {
      if (sequentialDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) sequentialDependencies.getNextOf (object);
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getNextOfSequentialDependencies ( OperationDependencies object, int index)
   {
      if (sequentialDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) sequentialDependencies.getNextOf (object, index);
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getPreviousOfSequentialDependencies ( OperationDependencies object)
   {
      if (sequentialDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) sequentialDependencies.getPreviousOf (object);
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public OperationDependencies getPreviousOfSequentialDependencies ( OperationDependencies object, int index )
   {
      if (sequentialDependencies == null)
      {
         return null;
      }
      else
      {
         return (OperationDependencies) sequentialDependencies.getPreviousOf (object, index);
      }
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean addAfterOfSequentialDependencies ( OperationDependencies refObject, OperationDependencies value)
   {
      boolean changed = false;
      if (sequentialDependencies != null)
      {
         int index = sequentialDependencies.indexOf (refObject);
         changed = addToSequentialDependencies (index+1, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean addBeforeOfSequentialDependencies ( OperationDependencies refObject, OperationDependencies value)
   {
      boolean changed = false;
      if (sequentialDependencies != null)
      {
         int index = sequentialDependencies.indexOf (refObject);
         changed = addToSequentialDependencies (index, value);
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean addToSequentialDependencies (int index, OperationDependencies value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.sequentialDependencies == null)
         {
            this.sequentialDependencies = new FLinkedList<OperationDependencies> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfSequentialDependencies (value);
         if (oldIndex != index)
         {
            try
            {
            
               if (oldIndex > -1)
               {
                  sequentialDependencies.remove (oldIndex);
               }
               sequentialDependencies.add (index, value);
               if (oldIndex < 0)
               {
                  value.setEngine1 (this);
               }
               changed = true;
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean setInSequentialDependencies (int index, OperationDependencies value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.sequentialDependencies == null)
         {
            this.sequentialDependencies = new FLinkedList<OperationDependencies> (); // or FTreeSet () or FLinkedList ()
         }
         int oldIndex = this.indexOfSequentialDependencies (value);
         if (oldIndex != index)
         {
            try
            {
            
               OperationDependencies oldValue = (OperationDependencies)this.sequentialDependencies.set (index, value);
               if (oldIndex > -1)
               {
                  this.sequentialDependencies.remove (oldIndex);
               }
               if (oldValue != value)
               {
                  if (oldValue != null)
                  {
                     oldValue.setEngine1 (null);
                  }
                  if (oldIndex < 0)
                  {
                     value.setEngine1 (this);
                  }
                  changed = true;
               }
            
            }
            catch (IndexOutOfBoundsException ex)
            {
               return false;
            }
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean removeFromSequentialDependencies (int index)
   {
      boolean changed = false;

      if (this.sequentialDependencies != null && (index >= 0 && index < this.sequentialDependencies.size ()))
      {
      
         OperationDependencies tmpValue = (OperationDependencies) this.sequentialDependencies.remove (index);
         if (tmpValue != null)
         {
            tmpValue.setEngine1 (null);
            changed = true;
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public boolean removeFromSequentialDependencies (int index, OperationDependencies value)
   {
      boolean changed = false;

      if ((this.sequentialDependencies != null) && (value != null) && 
          (index >= 0 && index < this.sequentialDependencies.size ()))
      {
         OperationDependencies oldValue = (OperationDependencies) this.sequentialDependencies.get (index);
         if (oldValue == value)
         {
         
            changed = this.removeFromSequentialDependencies (index);
         
         }
      }
      return changed;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public ListIterator<? extends OperationDependencies> iteratorOfSequentialDependencies ( OperationDependencies  lowerBound )
   {
      ListIterator<OperationDependencies> result = FEmptyListIterator.<OperationDependencies>get ();

      if (sequentialDependencies != null && lowerBound != null)
      {
         int index = sequentialDependencies.indexOf (lowerBound) + 1;
         result = sequentialDependencies.listIterator (index);
      }
      else if (sequentialDependencies != null && lowerBound == null)
      {
         result = sequentialDependencies.listIterator (0);
      }

      return result;
   }

   @Property( name = PROPERTY_SEQUENTIAL_DEPENDENCIES )
   public ListIterator<? extends OperationDependencies> iteratorOfSequentialDependencies (int index)
   {
      return ((this.sequentialDependencies == null)
              ? FEmptyListIterator.<OperationDependencies>get ()
              : this.sequentialDependencies.listIterator (Math.max(0,Math.min(index,this.sequentialDependencies.size ()))));
   }

   protected void setupCostStrategies ()
   {
      boolean fujaba__Success = false;
      To1CostStrategy to1 = null;
      SortedToNCostStrategy sorted = null;
      KeyedSortedToNCostStrategy keyedSorted = null;
      OrderedToNCostStrategy ordered = null;
      KeyedOrderedToNCostStrategy keyedOrdered = null;
      PathCostStrategy path = null;
      ConstraintsCostStrategy constr = null;
      ComparisonsCostStrategy comp = null;
      AttrCheckCostStrategy attr = null;
      MutatorBlockCostStrategy mutator = null;
      AssignCostStrategy assign = null;
      HashedToNCostStrategy hashed = null;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // create object to1
         to1 = new To1CostStrategy ( );

         // create object sorted
         sorted = new SortedToNCostStrategy ( );

         // create object keyedSorted
         keyedSorted = new KeyedSortedToNCostStrategy ( );

         // create object ordered
         ordered = new OrderedToNCostStrategy ( );

         // create object keyedOrdered
         keyedOrdered = new KeyedOrderedToNCostStrategy ( );

         // create object path
         path = new PathCostStrategy ( );

         // create object constr
         constr = new ConstraintsCostStrategy ( );

         // create object comp
         comp = new ComparisonsCostStrategy ( );

         // create object attr
         attr = new AttrCheckCostStrategy ( );

         // create object mutator
         mutator = new MutatorBlockCostStrategy ( );

         // create object assign
         assign = new AssignCostStrategy ( );

         // create object hashed
         hashed = new HashedToNCostStrategy ( );

         // create link costStrategies from to1 to this
         to1.setEngine (this);

         // create link costStrategies from sorted to this
         sorted.setEngine (this);

         // create link costStrategies from keyedSorted to this
         keyedSorted.setEngine (this);

         // create link costStrategies from ordered to this
         ordered.setEngine (this);

         // create link costStrategies from keyedOrdered to this
         keyedOrdered.setEngine (this);

         // create link costStrategies from path to this
         path.setEngine (this);

         // create link costStrategies from constr to this
         constr.setEngine (this);

         // create link costStrategies from comp to this
         comp.setEngine (this);

         // create link costStrategies from attr to this
         attr.setEngine (this);

         // create link costStrategies from mutator to this
         mutator.setEngine (this);

         // create link costStrategies from assign to this
         assign.setEngine (this);

         // create link costStrategies from this to hashed
         this.addToCostStrategies (hashed);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   protected void setupDependencies ()
   {
      boolean fujaba__Success = false;
      NeededObjectsBound needed = null;
      MutatingOperationDependencies mutating = null;
      ForEachMutatorBlockDependencies block = null;
      ConstraintDependencies constraints = null;
      CreateObjectsDependencies objs = null;
      CreateLinksDependencies links = null;
      AttributeAssignmentDependencies attrs = null;
      CollabStatDependencies collabStats = null;
      CreateMultiLinksDependencies multiLinks = null;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // create object needed
         needed = new NeededObjectsBound ( );

         // create object mutating
         mutating = new MutatingOperationDependencies ( );

         // create object block
         block = new ForEachMutatorBlockDependencies ( );

         // create object constraints
         constraints = new ConstraintDependencies ( );

         // create link nestingDependencies from needed to this
         needed.setEngine (this);

         // create link nestingDependencies from mutating to this
         mutating.setEngine (this);

         // create link nestingDependencies from block to this
         block.setEngine (this);

         // create link nestingDependencies from constraints to this
         constraints.setEngine (this);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // check object mutating is really bound
         JavaSDM.ensure ( mutating != null );
         // create object objs
         objs = new CreateObjectsDependencies ( );

         // create object links
         links = new CreateLinksDependencies ( );

         // create object attrs
         attrs = new AttributeAssignmentDependencies ( );

         // create object collabStats
         collabStats = new CollabStatDependencies ( );

         // create object multiLinks
         multiLinks = new CreateMultiLinksDependencies ( );

         // create link sequentialDependencies from objs to this
         objs.setEngine1 (this);

         // create link sequentialDependencies from links to this
         links.setEngine1 (this);

         // create link sequentialDependencies from mutating to this
         mutating.setEngine1 (this);

         // create link sequentialDependencies from attrs to this
         attrs.setEngine1 (this);

         // create link sequentialDependencies from collabStats to this
         collabStats.setEngine1 (this);

         // create link sequentialDependencies from multiLinks to this
         multiLinks.setEngine1 (this);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   protected void setupMutators ()
   {
      boolean fujaba__Success = false;
      AddCollabStatsMutator collab = null;
      ModifyObjectsMutator modObj = null;
      CreateMutatorBlockMutator block = null;
      BoundObjectMutator bound = null;
      SearchTreeMutator search = null;
      UnusedOperationsMutator unused = null;
      OtherPreconditionsMutator other = null;
      ModificationsMutator mods = null;
      CreateSetModificationBlocksMutator cSet = null;
      UnfoldTreeMutator unfold = null;
      CreateOptionalBlocksMutator cOpt = null;
      CreateNegativeBlocksMutator cNeg = null;
      ForEachMutator foreach = null;
      PostponeMutatorBlockMutator pMut = null;
      OperationSorterMutator sorterMutator = null;
      OperationCostComparator comp = null;
      OperationSorter sorter = null;

      // Order of mutators

      // AddCollabStatsMutator - create collabstat tokens
      // ModifyObjectsMutator - create create/destroy object tokens
      // CreateMutatorBlockMutator - create MutatorBlock token
      // BoundObjectMutator - Create bound object tokens and add them to the tree
      // SearchTreeMutator - build search tree
      // UnusedOperationsMutator - remove unused linkchecks and searches
      // OtherPreconditionsMutator - add checks to tree
      // CreateNegativeBlocksMutator - add blocks
      // ModificationsMutator - add postconditions
      // CreateOptionalBlocksMutator - "
      // CreateSetModificationBlocksMutator- "
      // OperationSorter - sorts the elements on each level by cost
      // UnfoldTreeMutator - children which are are no composites are unfolded
      // PostponeMutatorBlockMutator - places Mutator block at the very end
      // ForEachMutator - places each time branch in inner loop of for each activity

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // create object collab
         collab = new AddCollabStatsMutator ( );

         // create object modObj
         modObj = new ModifyObjectsMutator ( );

         // create object block
         block = new CreateMutatorBlockMutator ( );

         // create object bound
         bound = new BoundObjectMutator ( );

         // create object search
         search = new SearchTreeMutator ( );

         // create object unused
         unused = new UnusedOperationsMutator ( );

         // create object other
         other = new OtherPreconditionsMutator ( );

         // create object mods
         mods = new ModificationsMutator ( );

         // create object cSet
         cSet = new CreateSetModificationBlocksMutator ( );

         // create object unfold
         unfold = new UnfoldTreeMutator ( );

         // create object cOpt
         cOpt = new CreateOptionalBlocksMutator ( );

         // create object cNeg
         cNeg = new CreateNegativeBlocksMutator ( );

         // create object foreach
         foreach = new ForEachMutator ( );

         // create object pMut
         pMut = new PostponeMutatorBlockMutator ( );

         // create object sorterMutator
         sorterMutator = new OperationSorterMutator ( );

         // create object comp
         comp = new OperationCostComparator ( );

         // create object sorter
         sorter = new OperationSorter ( );

         // create link planEngine from comp to this
         comp.setPlanEngine (this);

         // create link mutators from this to collab
         this.addToMutators (collab);

         // create link mutators from this to modObj
         this.addAfterOfMutators (collab, modObj);

         // create link mutators from this to block
         this.addAfterOfMutators (modObj, block);

         // create link comparator from sorter to comp
         sorter.setComparator (comp);

         // create link sorter from sorterMutator to sorter
         sorterMutator.setSorter (sorter);

         // create link mutators from this to bound
         this.addAfterOfMutators (block, bound);

         // create link mutators from this to search
         this.addAfterOfMutators (bound, search);

         // create link mutators from this to unused
         this.addAfterOfMutators (search, unused);

         // create link mutators from this to other
         this.addAfterOfMutators (unused, other);

         // create link mutators from this to cNeg
         this.addAfterOfMutators (other, cNeg);

         // create link mutators from this to mods
         this.addAfterOfMutators (cNeg, mods);

         // create link mutators from this to cOpt
         this.addAfterOfMutators (mods, cOpt);

         // create link mutators from this to cSet
         this.addAfterOfMutators (cOpt, cSet);

         // create link mutators from this to sorterMutator
         this.addAfterOfMutators (cSet, sorterMutator);

         // create link mutators from this to unfold
         this.addAfterOfMutators (sorterMutator, unfold);

         // create link mutators from this to pMut
         this.addAfterOfMutators (unfold, pMut);

         // create link mutators from this to foreach
         this.addAfterOfMutators (pMut, foreach);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   protected void setupPayloadStrategies ()
   {
      boolean fujaba__Success = false;
      QualifiedPayloadStrategy qualified = null;
      DefaultPayloadStrategy dflt = null;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // create object qualified
         qualified = new QualifiedPayloadStrategy ( );

         // create object dflt
         dflt = new DefaultPayloadStrategy ( );

         // create link payloadStrategies from qualified to this
         qualified.setEngine (this);

         // create link payloadStrategies from dflt to this
         dflt.setEngine (this);

         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   public void setup ()
   {
      boolean fujaba__Success = false;

      // story pattern storypatternwiththis
      try 
      {
         fujaba__Success = false; 

         // collabStat call
         this.setupCostStrategies();
         // collabStat call
         this.setupDependencies();
         // collabStat call
         this.setupMutators();
         // collabStat call
         this.setupPayloadStrategies();
         fujaba__Success = true;
      }
      catch ( JavaSDMException fujaba__InternalException )
      {
         fujaba__Success = false;
      }

      return ;
   }

   public void removeYou()
   {
      this.removeAllFromCostStrategies ();
      this.removeAllFromMutators ();
      this.removeAllFromNestingDependencies ();
      this.removeAllFromPayloadStrategies ();
      this.removeAllFromSequentialDependencies ();
      super.removeYou ();
   }
}


