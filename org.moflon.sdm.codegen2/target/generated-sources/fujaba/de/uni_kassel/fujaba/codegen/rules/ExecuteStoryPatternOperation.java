/*
 * generated by Fujaba - CodeGen2
 */
package de.uni_kassel.fujaba.codegen.rules;
import java.util.Collections;
import java.util.Iterator;
import java.util.Set;

import de.uni_kassel.features.ReferenceHandler; // requires Fujaba5/libs/features.jar in classpath
import de.uni_kassel.features.annotation.util.Property; // requires Fujaba5/libs/features.jar in classpath
import de.uni_paderborn.fujaba.uml.behavior.UMLStoryPattern;
import de.upb.tools.fca.FEmptyIterator;
import de.upb.tools.fca.FHashSet; // requires Fujaba5/libs/RuntimeTools.jar in classpath


public class ExecuteStoryPatternOperation extends Operation implements Block
{


   /**
    * <pre>
    *           0..1     objects     0..1
    * ExecuteStoryPatternOperation ------------------------> ObjectSet
    *           executeStoryPatternOperation               objects
    * </pre>
    */
   public static final String PROPERTY_OBJECTS = "objects";

   @Property( name = PROPERTY_OBJECTS, kind = ReferenceHandler.ReferenceKind.TO_ONE,
         adornment = ReferenceHandler.Adornment.NONE)
   private ObjectSet objects;

   @Property( name = PROPERTY_OBJECTS )
   public boolean setObjects (ObjectSet value)
   {
      boolean changed = false;

      if (this.objects != value)
      {
      
         ObjectSet oldValue = this.objects;
         this.objects = value;
         changed = true;
      
      }
      return changed;
   }

   @Property( name = PROPERTY_OBJECTS )
   public ExecuteStoryPatternOperation withObjects (ObjectSet value)
   {
      setObjects (value);
      return this;
   }

   public ObjectSet getObjects ()
   {
      return this.objects;
   }

   /**
    * <pre>
    *           0..1     operations     0..n
    * ExecuteStoryPatternOperation ------------------------- Operation
    *           storyPatternOperation               operations
    * </pre>
    */
   public static final String PROPERTY_OPERATIONS = "operations";

   @Property( name = PROPERTY_OPERATIONS, partner = Operation.PROPERTY_STORY_PATTERN_OPERATION, kind = ReferenceHandler.ReferenceKind.TO_MANY,
         adornment = ReferenceHandler.Adornment.NONE)
   private FHashSet<Operation> operations;

   @Property( name = PROPERTY_OPERATIONS )
   public Set<? extends Operation> getOperations()
   {
      return ((this.operations == null)
              ? Collections.EMPTY_SET
              : Collections.unmodifiableSet(this.operations));
   }

   @Property( name = PROPERTY_OPERATIONS )
   public boolean addToOperations (Operation value)
   {
      boolean changed = false;

      if (value != null)
      {
         if (this.operations == null)
         {
            this.operations = new FHashSet<Operation> ();

         }
      
         changed = this.operations.add (value);
         if (changed)
         {
            value.setStoryPatternOperation (this);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_OPERATIONS )
   public ExecuteStoryPatternOperation withOperations (Operation value)
   {
      addToOperations (value);
      return this;
   }

   public ExecuteStoryPatternOperation withoutOperations (Operation value)
   {
      removeFromOperations (value);
      return this;
   }


   public boolean removeFromOperations (Operation value)
   {
      boolean changed = false;

      if ((this.operations != null) && (value != null))
      {
      
         changed = this.operations.remove (value);
         if (changed)
         {
            value.setStoryPatternOperation (null);
         }
      
      }
      return changed;
   }

   @Property( name = PROPERTY_OPERATIONS )
   public void removeAllFromOperations (){
   
      Operation tmpValue;
      Iterator<? extends Operation> iter = this.iteratorOfOperations ();
      while (iter.hasNext ())
      {
         tmpValue = (Operation) iter.next ();
         this.removeFromOperations (tmpValue);
      }
   
   }

   @Property( name = PROPERTY_OPERATIONS )
   public boolean hasInOperations (Operation value)
   {
      return ((this.operations != null) &&
              (value != null) &&
              this.operations.contains (value));
   }

   @Property( name = PROPERTY_OPERATIONS )
   public Iterator<? extends Operation> iteratorOfOperations ()
   {
      return ((this.operations == null)
              ? FEmptyIterator.<Operation>get ()
              : this.operations.iterator ());
   }

   @Property( name = PROPERTY_OPERATIONS )
   public int sizeOfOperations ()
   {
      return ((this.operations == null)
              ? 0
              : this.operations.size ());
   }

   /**
    * <pre>
    *           0..1     storyPattern     0..1
    * ExecuteStoryPatternOperation ------------------------> UMLStoryPattern
    *           executeStoryPatternOperation               storyPattern
    * </pre>
    */
   public static final String PROPERTY_STORY_PATTERN = "storyPattern";

   @Property( name = PROPERTY_STORY_PATTERN, kind = ReferenceHandler.ReferenceKind.TO_ONE,
         adornment = ReferenceHandler.Adornment.NONE)
   private UMLStoryPattern storyPattern;

   @Property( name = PROPERTY_STORY_PATTERN )
   public boolean setStoryPattern (UMLStoryPattern value)
   {
      boolean changed = false;

      if (this.storyPattern != value)
      {
      
         UMLStoryPattern oldValue = this.storyPattern;
         this.storyPattern = value;
         changed = true;
      
      }
      return changed;
   }

   @Property( name = PROPERTY_STORY_PATTERN )
   public ExecuteStoryPatternOperation withStoryPattern (UMLStoryPattern value)
   {
      setStoryPattern (value);
      return this;
   }

   public UMLStoryPattern getStoryPattern ()
   {
      return this.storyPattern;
   }

   public void removeYou()
   {
      this.setObjects (null);
      this.removeAllFromOperations ();
      this.setStoryPattern (null);
      super.removeYou ();
   }
}


