
partial class AcTheorySolverImpl {

@members <--

	private Model getAllModels(BoolExpr exp)
	{
		Model model=checkSat(ctx, exp);
		model.
	}
	private BoolExpr getBoolExpr(SymbolicGraph graphG, Context ctx)
	{
		List<BoolExpr> boolExpressions=graphG.getConditions().stream().map(x->this.getBoolExpr(x, ctx)).collect(Collectors.toList());
		try {
			return ctx.mkAnd((BoolExpr[]) boolExpressions.toArray());
		} catch (Z3Exception e) {
			// TODO Auto-generated catch block
			throw new RuntimeException(e.getCause());
		}
		
	}
	private BoolExpr getBoolExpr(Condition cond, Context ctx) 
	{
		try {
		if(cond instanceof TrueCond)
		{
				return ctx.mkBool(true);
			
		}
		else if(cond instanceof NegCond)
		{
			NegCond negCond=(NegCond) cond;
			return ctx.mkNot(getBoolExpr(negCond.getNegCondition(), ctx));
		}
		else if(cond instanceof AndCond)
		{
			AndCond andCond=(AndCond) cond;
			if(andCond.getConditions().isEmpty())
			{
				return ctx.mkBool(false);
			}
			else
			{
				List<BoolExpr> boolExpressions=andCond.getConditions().stream().map(x->this.getBoolExpr(x, ctx)).collect(Collectors.toList());
				return ctx.mkAnd((BoolExpr[]) boolExpressions.toArray());
			}
			
		}
		else if(cond instanceof AtomicCond)
		{
			BoolExpr x = ctx.mkBoolConst("ac!"+ac_counter++);
			varToCondMap.put(x, (AtomicCond) cond);
			return x;
		}
		} catch (Z3Exception e) {
			// TODO Auto-generated catch block
			throw new RuntimeException(e.getCause());
		}

		return null;
	}
	private Model checkSat(Context ctx, BoolExpr f) 
	{
		Solver s;
		try {
			s = ctx.mkSolver();
			s.add(f);
			if (s.check()== Status.SATISFIABLE)
				return s.getModel();
			else
				return null;
		} catch (Z3Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	private int ac_counter=0;
	private HashMap<BoolExpr, AtomicCond>varToCondMap=new HashMap<BoolExpr, AtomicCond>();
	
-->

}